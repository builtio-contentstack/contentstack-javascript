module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/core/contentstack.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./config.js":
/*!*******************!*\
  !*** ./config.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar config = {\n    protocol: \"https\",\n    host: \"cdn.contentstack.io\",\n    port: 443,\n    version: \"v3\",\n    urls: {\n        sync: \"/stacks/sync\",\n        content_types: \"/content_types/\",\n        entries: \"/entries/\",\n        assets: \"/assets/\",\n        environments: \"/environments/\"\n    }\n};\n\nexports.default = config;\n\n//# sourceURL=webpack://Contentstack/./config.js?");

/***/ }),

/***/ "./node_modules/es6-promise/dist/es6-promise.js":
/*!******************************************************!*\
  !*** ./node_modules/es6-promise/dist/es6-promise.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;var require;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE\n * @version   4.1.1\n */\n\n(function (global, factory) {\n  ( false ? undefined : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;\n})(undefined, function () {\n  'use strict';\n\n  function objectOrFunction(x) {\n    var type = typeof x === 'undefined' ? 'undefined' : _typeof(x);\n    return x !== null && (type === 'object' || type === 'function');\n  }\n\n  function isFunction(x) {\n    return typeof x === 'function';\n  }\n\n  var _isArray = undefined;\n  if (Array.isArray) {\n    _isArray = Array.isArray;\n  } else {\n    _isArray = function _isArray(x) {\n      return Object.prototype.toString.call(x) === '[object Array]';\n    };\n  }\n\n  var isArray = _isArray;\n\n  var len = 0;\n  var vertxNext = undefined;\n  var customSchedulerFn = undefined;\n\n  var asap = function asap(callback, arg) {\n    queue[len] = callback;\n    queue[len + 1] = arg;\n    len += 2;\n    if (len === 2) {\n      // If len is 2, that means that we need to schedule an async flush.\n      // If additional callbacks are queued before the queue is flushed, they\n      // will be processed by this flush that we are scheduling.\n      if (customSchedulerFn) {\n        customSchedulerFn(flush);\n      } else {\n        scheduleFlush();\n      }\n    }\n  };\n\n  function setScheduler(scheduleFn) {\n    customSchedulerFn = scheduleFn;\n  }\n\n  function setAsap(asapFn) {\n    asap = asapFn;\n  }\n\n  var browserWindow = typeof window !== 'undefined' ? window : undefined;\n  var browserGlobal = browserWindow || {};\n  var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;\n  var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n  // test for web worker but not in IE10\n  var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';\n\n  // node\n  function useNextTick() {\n    // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n    // see https://github.com/cujojs/when/issues/410 for details\n    return function () {\n      return process.nextTick(flush);\n    };\n  }\n\n  // vertx\n  function useVertxTimer() {\n    if (typeof vertxNext !== 'undefined') {\n      return function () {\n        vertxNext(flush);\n      };\n    }\n\n    return useSetTimeout();\n  }\n\n  function useMutationObserver() {\n    var iterations = 0;\n    var observer = new BrowserMutationObserver(flush);\n    var node = document.createTextNode('');\n    observer.observe(node, { characterData: true });\n\n    return function () {\n      node.data = iterations = ++iterations % 2;\n    };\n  }\n\n  // web worker\n  function useMessageChannel() {\n    var channel = new MessageChannel();\n    channel.port1.onmessage = flush;\n    return function () {\n      return channel.port2.postMessage(0);\n    };\n  }\n\n  function useSetTimeout() {\n    // Store setTimeout reference so es6-promise will be unaffected by\n    // other code modifying setTimeout (like sinon.useFakeTimers())\n    var globalSetTimeout = setTimeout;\n    return function () {\n      return globalSetTimeout(flush, 1);\n    };\n  }\n\n  var queue = new Array(1000);\n  function flush() {\n    for (var i = 0; i < len; i += 2) {\n      var callback = queue[i];\n      var arg = queue[i + 1];\n\n      callback(arg);\n\n      queue[i] = undefined;\n      queue[i + 1] = undefined;\n    }\n\n    len = 0;\n  }\n\n  function attemptVertx() {\n    try {\n      var r = require;\n      var vertx = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'vertx'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n      vertxNext = vertx.runOnLoop || vertx.runOnContext;\n      return useVertxTimer();\n    } catch (e) {\n      return useSetTimeout();\n    }\n  }\n\n  var scheduleFlush = undefined;\n  // Decide what async method to use to triggering processing of queued callbacks:\n  if (isNode) {\n    scheduleFlush = useNextTick();\n  } else if (BrowserMutationObserver) {\n    scheduleFlush = useMutationObserver();\n  } else if (isWorker) {\n    scheduleFlush = useMessageChannel();\n  } else if (browserWindow === undefined && \"function\" === 'function') {\n    scheduleFlush = attemptVertx();\n  } else {\n    scheduleFlush = useSetTimeout();\n  }\n\n  function then(onFulfillment, onRejection) {\n    var _arguments = arguments;\n\n    var parent = this;\n\n    var child = new this.constructor(noop);\n\n    if (child[PROMISE_ID] === undefined) {\n      makePromise(child);\n    }\n\n    var _state = parent._state;\n\n    if (_state) {\n      (function () {\n        var callback = _arguments[_state - 1];\n        asap(function () {\n          return invokeCallback(_state, child, callback, parent._result);\n        });\n      })();\n    } else {\n      subscribe(parent, child, onFulfillment, onRejection);\n    }\n\n    return child;\n  }\n\n  /**\n    `Promise.resolve` returns a promise that will become resolved with the\n    passed `value`. It is shorthand for the following:\n  \n    ```javascript\n    let promise = new Promise(function(resolve, reject){\n      resolve(1);\n    });\n  \n    promise.then(function(value){\n      // value === 1\n    });\n    ```\n  \n    Instead of writing the above, your code now simply becomes the following:\n  \n    ```javascript\n    let promise = Promise.resolve(1);\n  \n    promise.then(function(value){\n      // value === 1\n    });\n    ```\n  \n    @method resolve\n    @static\n    @param {Any} value value that the returned promise will be resolved with\n    Useful for tooling.\n    @return {Promise} a promise that will become fulfilled with the given\n    `value`\n  */\n  function resolve$1(object) {\n    /*jshint validthis:true */\n    var Constructor = this;\n\n    if (object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object.constructor === Constructor) {\n      return object;\n    }\n\n    var promise = new Constructor(noop);\n    resolve(promise, object);\n    return promise;\n  }\n\n  var PROMISE_ID = Math.random().toString(36).substring(16);\n\n  function noop() {}\n\n  var PENDING = void 0;\n  var FULFILLED = 1;\n  var REJECTED = 2;\n\n  var GET_THEN_ERROR = new ErrorObject();\n\n  function selfFulfillment() {\n    return new TypeError(\"You cannot resolve a promise with itself\");\n  }\n\n  function cannotReturnOwn() {\n    return new TypeError('A promises callback cannot return that same promise.');\n  }\n\n  function getThen(promise) {\n    try {\n      return promise.then;\n    } catch (error) {\n      GET_THEN_ERROR.error = error;\n      return GET_THEN_ERROR;\n    }\n  }\n\n  function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {\n    try {\n      then$$1.call(value, fulfillmentHandler, rejectionHandler);\n    } catch (e) {\n      return e;\n    }\n  }\n\n  function handleForeignThenable(promise, thenable, then$$1) {\n    asap(function (promise) {\n      var sealed = false;\n      var error = tryThen(then$$1, thenable, function (value) {\n        if (sealed) {\n          return;\n        }\n        sealed = true;\n        if (thenable !== value) {\n          resolve(promise, value);\n        } else {\n          fulfill(promise, value);\n        }\n      }, function (reason) {\n        if (sealed) {\n          return;\n        }\n        sealed = true;\n\n        reject(promise, reason);\n      }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n      if (!sealed && error) {\n        sealed = true;\n        reject(promise, error);\n      }\n    }, promise);\n  }\n\n  function handleOwnThenable(promise, thenable) {\n    if (thenable._state === FULFILLED) {\n      fulfill(promise, thenable._result);\n    } else if (thenable._state === REJECTED) {\n      reject(promise, thenable._result);\n    } else {\n      subscribe(thenable, undefined, function (value) {\n        return resolve(promise, value);\n      }, function (reason) {\n        return reject(promise, reason);\n      });\n    }\n  }\n\n  function handleMaybeThenable(promise, maybeThenable, then$$1) {\n    if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {\n      handleOwnThenable(promise, maybeThenable);\n    } else {\n      if (then$$1 === GET_THEN_ERROR) {\n        reject(promise, GET_THEN_ERROR.error);\n        GET_THEN_ERROR.error = null;\n      } else if (then$$1 === undefined) {\n        fulfill(promise, maybeThenable);\n      } else if (isFunction(then$$1)) {\n        handleForeignThenable(promise, maybeThenable, then$$1);\n      } else {\n        fulfill(promise, maybeThenable);\n      }\n    }\n  }\n\n  function resolve(promise, value) {\n    if (promise === value) {\n      reject(promise, selfFulfillment());\n    } else if (objectOrFunction(value)) {\n      handleMaybeThenable(promise, value, getThen(value));\n    } else {\n      fulfill(promise, value);\n    }\n  }\n\n  function publishRejection(promise) {\n    if (promise._onerror) {\n      promise._onerror(promise._result);\n    }\n\n    publish(promise);\n  }\n\n  function fulfill(promise, value) {\n    if (promise._state !== PENDING) {\n      return;\n    }\n\n    promise._result = value;\n    promise._state = FULFILLED;\n\n    if (promise._subscribers.length !== 0) {\n      asap(publish, promise);\n    }\n  }\n\n  function reject(promise, reason) {\n    if (promise._state !== PENDING) {\n      return;\n    }\n    promise._state = REJECTED;\n    promise._result = reason;\n\n    asap(publishRejection, promise);\n  }\n\n  function subscribe(parent, child, onFulfillment, onRejection) {\n    var _subscribers = parent._subscribers;\n    var length = _subscribers.length;\n\n    parent._onerror = null;\n\n    _subscribers[length] = child;\n    _subscribers[length + FULFILLED] = onFulfillment;\n    _subscribers[length + REJECTED] = onRejection;\n\n    if (length === 0 && parent._state) {\n      asap(publish, parent);\n    }\n  }\n\n  function publish(promise) {\n    var subscribers = promise._subscribers;\n    var settled = promise._state;\n\n    if (subscribers.length === 0) {\n      return;\n    }\n\n    var child = undefined,\n        callback = undefined,\n        detail = promise._result;\n\n    for (var i = 0; i < subscribers.length; i += 3) {\n      child = subscribers[i];\n      callback = subscribers[i + settled];\n\n      if (child) {\n        invokeCallback(settled, child, callback, detail);\n      } else {\n        callback(detail);\n      }\n    }\n\n    promise._subscribers.length = 0;\n  }\n\n  function ErrorObject() {\n    this.error = null;\n  }\n\n  var TRY_CATCH_ERROR = new ErrorObject();\n\n  function tryCatch(callback, detail) {\n    try {\n      return callback(detail);\n    } catch (e) {\n      TRY_CATCH_ERROR.error = e;\n      return TRY_CATCH_ERROR;\n    }\n  }\n\n  function invokeCallback(settled, promise, callback, detail) {\n    var hasCallback = isFunction(callback),\n        value = undefined,\n        error = undefined,\n        succeeded = undefined,\n        failed = undefined;\n\n    if (hasCallback) {\n      value = tryCatch(callback, detail);\n\n      if (value === TRY_CATCH_ERROR) {\n        failed = true;\n        error = value.error;\n        value.error = null;\n      } else {\n        succeeded = true;\n      }\n\n      if (promise === value) {\n        reject(promise, cannotReturnOwn());\n        return;\n      }\n    } else {\n      value = detail;\n      succeeded = true;\n    }\n\n    if (promise._state !== PENDING) {\n      // noop\n    } else if (hasCallback && succeeded) {\n      resolve(promise, value);\n    } else if (failed) {\n      reject(promise, error);\n    } else if (settled === FULFILLED) {\n      fulfill(promise, value);\n    } else if (settled === REJECTED) {\n      reject(promise, value);\n    }\n  }\n\n  function initializePromise(promise, resolver) {\n    try {\n      resolver(function resolvePromise(value) {\n        resolve(promise, value);\n      }, function rejectPromise(reason) {\n        reject(promise, reason);\n      });\n    } catch (e) {\n      reject(promise, e);\n    }\n  }\n\n  var id = 0;\n  function nextId() {\n    return id++;\n  }\n\n  function makePromise(promise) {\n    promise[PROMISE_ID] = id++;\n    promise._state = undefined;\n    promise._result = undefined;\n    promise._subscribers = [];\n  }\n\n  function Enumerator$1(Constructor, input) {\n    this._instanceConstructor = Constructor;\n    this.promise = new Constructor(noop);\n\n    if (!this.promise[PROMISE_ID]) {\n      makePromise(this.promise);\n    }\n\n    if (isArray(input)) {\n      this.length = input.length;\n      this._remaining = input.length;\n\n      this._result = new Array(this.length);\n\n      if (this.length === 0) {\n        fulfill(this.promise, this._result);\n      } else {\n        this.length = this.length || 0;\n        this._enumerate(input);\n        if (this._remaining === 0) {\n          fulfill(this.promise, this._result);\n        }\n      }\n    } else {\n      reject(this.promise, validationError());\n    }\n  }\n\n  function validationError() {\n    return new Error('Array Methods must be provided an Array');\n  }\n\n  Enumerator$1.prototype._enumerate = function (input) {\n    for (var i = 0; this._state === PENDING && i < input.length; i++) {\n      this._eachEntry(input[i], i);\n    }\n  };\n\n  Enumerator$1.prototype._eachEntry = function (entry, i) {\n    var c = this._instanceConstructor;\n    var resolve$$1 = c.resolve;\n\n    if (resolve$$1 === resolve$1) {\n      var _then = getThen(entry);\n\n      if (_then === then && entry._state !== PENDING) {\n        this._settledAt(entry._state, i, entry._result);\n      } else if (typeof _then !== 'function') {\n        this._remaining--;\n        this._result[i] = entry;\n      } else if (c === Promise$2) {\n        var promise = new c(noop);\n        handleMaybeThenable(promise, entry, _then);\n        this._willSettleAt(promise, i);\n      } else {\n        this._willSettleAt(new c(function (resolve$$1) {\n          return resolve$$1(entry);\n        }), i);\n      }\n    } else {\n      this._willSettleAt(resolve$$1(entry), i);\n    }\n  };\n\n  Enumerator$1.prototype._settledAt = function (state, i, value) {\n    var promise = this.promise;\n\n    if (promise._state === PENDING) {\n      this._remaining--;\n\n      if (state === REJECTED) {\n        reject(promise, value);\n      } else {\n        this._result[i] = value;\n      }\n    }\n\n    if (this._remaining === 0) {\n      fulfill(promise, this._result);\n    }\n  };\n\n  Enumerator$1.prototype._willSettleAt = function (promise, i) {\n    var enumerator = this;\n\n    subscribe(promise, undefined, function (value) {\n      return enumerator._settledAt(FULFILLED, i, value);\n    }, function (reason) {\n      return enumerator._settledAt(REJECTED, i, reason);\n    });\n  };\n\n  /**\n    `Promise.all` accepts an array of promises, and returns a new promise which\n    is fulfilled with an array of fulfillment values for the passed promises, or\n    rejected with the reason of the first passed promise to be rejected. It casts all\n    elements of the passed iterable to promises as it runs this algorithm.\n  \n    Example:\n  \n    ```javascript\n    let promise1 = resolve(1);\n    let promise2 = resolve(2);\n    let promise3 = resolve(3);\n    let promises = [ promise1, promise2, promise3 ];\n  \n    Promise.all(promises).then(function(array){\n      // The array here would be [ 1, 2, 3 ];\n    });\n    ```\n  \n    If any of the `promises` given to `all` are rejected, the first promise\n    that is rejected will be given as an argument to the returned promises's\n    rejection handler. For example:\n  \n    Example:\n  \n    ```javascript\n    let promise1 = resolve(1);\n    let promise2 = reject(new Error(\"2\"));\n    let promise3 = reject(new Error(\"3\"));\n    let promises = [ promise1, promise2, promise3 ];\n  \n    Promise.all(promises).then(function(array){\n      // Code here never runs because there are rejected promises!\n    }, function(error) {\n      // error.message === \"2\"\n    });\n    ```\n  \n    @method all\n    @static\n    @param {Array} entries array of promises\n    @param {String} label optional string for labeling the promise.\n    Useful for tooling.\n    @return {Promise} promise that is fulfilled when all `promises` have been\n    fulfilled, or rejected if any of them become rejected.\n    @static\n  */\n  function all$1(entries) {\n    return new Enumerator$1(this, entries).promise;\n  }\n\n  /**\n    `Promise.race` returns a new promise which is settled in the same way as the\n    first passed promise to settle.\n  \n    Example:\n  \n    ```javascript\n    let promise1 = new Promise(function(resolve, reject){\n      setTimeout(function(){\n        resolve('promise 1');\n      }, 200);\n    });\n  \n    let promise2 = new Promise(function(resolve, reject){\n      setTimeout(function(){\n        resolve('promise 2');\n      }, 100);\n    });\n  \n    Promise.race([promise1, promise2]).then(function(result){\n      // result === 'promise 2' because it was resolved before promise1\n      // was resolved.\n    });\n    ```\n  \n    `Promise.race` is deterministic in that only the state of the first\n    settled promise matters. For example, even if other promises given to the\n    `promises` array argument are resolved, but the first settled promise has\n    become rejected before the other promises became fulfilled, the returned\n    promise will become rejected:\n  \n    ```javascript\n    let promise1 = new Promise(function(resolve, reject){\n      setTimeout(function(){\n        resolve('promise 1');\n      }, 200);\n    });\n  \n    let promise2 = new Promise(function(resolve, reject){\n      setTimeout(function(){\n        reject(new Error('promise 2'));\n      }, 100);\n    });\n  \n    Promise.race([promise1, promise2]).then(function(result){\n      // Code here never runs\n    }, function(reason){\n      // reason.message === 'promise 2' because promise 2 became rejected before\n      // promise 1 became fulfilled\n    });\n    ```\n  \n    An example real-world use case is implementing timeouts:\n  \n    ```javascript\n    Promise.race([ajax('foo.json'), timeout(5000)])\n    ```\n  \n    @method race\n    @static\n    @param {Array} promises array of promises to observe\n    Useful for tooling.\n    @return {Promise} a promise which settles in the same way as the first passed\n    promise to settle.\n  */\n  function race$1(entries) {\n    /*jshint validthis:true */\n    var Constructor = this;\n\n    if (!isArray(entries)) {\n      return new Constructor(function (_, reject) {\n        return reject(new TypeError('You must pass an array to race.'));\n      });\n    } else {\n      return new Constructor(function (resolve, reject) {\n        var length = entries.length;\n        for (var i = 0; i < length; i++) {\n          Constructor.resolve(entries[i]).then(resolve, reject);\n        }\n      });\n    }\n  }\n\n  /**\n    `Promise.reject` returns a promise rejected with the passed `reason`.\n    It is shorthand for the following:\n  \n    ```javascript\n    let promise = new Promise(function(resolve, reject){\n      reject(new Error('WHOOPS'));\n    });\n  \n    promise.then(function(value){\n      // Code here doesn't run because the promise is rejected!\n    }, function(reason){\n      // reason.message === 'WHOOPS'\n    });\n    ```\n  \n    Instead of writing the above, your code now simply becomes the following:\n  \n    ```javascript\n    let promise = Promise.reject(new Error('WHOOPS'));\n  \n    promise.then(function(value){\n      // Code here doesn't run because the promise is rejected!\n    }, function(reason){\n      // reason.message === 'WHOOPS'\n    });\n    ```\n  \n    @method reject\n    @static\n    @param {Any} reason value that the returned promise will be rejected with.\n    Useful for tooling.\n    @return {Promise} a promise rejected with the given `reason`.\n  */\n  function reject$1(reason) {\n    /*jshint validthis:true */\n    var Constructor = this;\n    var promise = new Constructor(noop);\n    reject(promise, reason);\n    return promise;\n  }\n\n  function needsResolver() {\n    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n  }\n\n  function needsNew() {\n    throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n  }\n\n  /**\n    Promise objects represent the eventual result of an asynchronous operation. The\n    primary way of interacting with a promise is through its `then` method, which\n    registers callbacks to receive either a promise's eventual value or the reason\n    why the promise cannot be fulfilled.\n  \n    Terminology\n    -----------\n  \n    - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n    - `thenable` is an object or function that defines a `then` method.\n    - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n    - `exception` is a value that is thrown using the throw statement.\n    - `reason` is a value that indicates why a promise was rejected.\n    - `settled` the final resting state of a promise, fulfilled or rejected.\n  \n    A promise can be in one of three states: pending, fulfilled, or rejected.\n  \n    Promises that are fulfilled have a fulfillment value and are in the fulfilled\n    state.  Promises that are rejected have a rejection reason and are in the\n    rejected state.  A fulfillment value is never a thenable.\n  \n    Promises can also be said to *resolve* a value.  If this value is also a\n    promise, then the original promise's settled state will match the value's\n    settled state.  So a promise that *resolves* a promise that rejects will\n    itself reject, and a promise that *resolves* a promise that fulfills will\n    itself fulfill.\n  \n  \n    Basic Usage:\n    ------------\n  \n    ```js\n    let promise = new Promise(function(resolve, reject) {\n      // on success\n      resolve(value);\n  \n      // on failure\n      reject(reason);\n    });\n  \n    promise.then(function(value) {\n      // on fulfillment\n    }, function(reason) {\n      // on rejection\n    });\n    ```\n  \n    Advanced Usage:\n    ---------------\n  \n    Promises shine when abstracting away asynchronous interactions such as\n    `XMLHttpRequest`s.\n  \n    ```js\n    function getJSON(url) {\n      return new Promise(function(resolve, reject){\n        let xhr = new XMLHttpRequest();\n  \n        xhr.open('GET', url);\n        xhr.onreadystatechange = handler;\n        xhr.responseType = 'json';\n        xhr.setRequestHeader('Accept', 'application/json');\n        xhr.send();\n  \n        function handler() {\n          if (this.readyState === this.DONE) {\n            if (this.status === 200) {\n              resolve(this.response);\n            } else {\n              reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n            }\n          }\n        };\n      });\n    }\n  \n    getJSON('/posts.json').then(function(json) {\n      // on fulfillment\n    }, function(reason) {\n      // on rejection\n    });\n    ```\n  \n    Unlike callbacks, promises are great composable primitives.\n  \n    ```js\n    Promise.all([\n      getJSON('/posts'),\n      getJSON('/comments')\n    ]).then(function(values){\n      values[0] // => postsJSON\n      values[1] // => commentsJSON\n  \n      return values;\n    });\n    ```\n  \n    @class Promise\n    @param {function} resolver\n    Useful for tooling.\n    @constructor\n  */\n  function Promise$2(resolver) {\n    this[PROMISE_ID] = nextId();\n    this._result = this._state = undefined;\n    this._subscribers = [];\n\n    if (noop !== resolver) {\n      typeof resolver !== 'function' && needsResolver();\n      this instanceof Promise$2 ? initializePromise(this, resolver) : needsNew();\n    }\n  }\n\n  Promise$2.all = all$1;\n  Promise$2.race = race$1;\n  Promise$2.resolve = resolve$1;\n  Promise$2.reject = reject$1;\n  Promise$2._setScheduler = setScheduler;\n  Promise$2._setAsap = setAsap;\n  Promise$2._asap = asap;\n\n  Promise$2.prototype = {\n    constructor: Promise$2,\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n    \n      ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n    \n      Chaining\n      --------\n    \n      The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n    \n      ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n    \n      findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n    \n      ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n    \n      Assimilation\n      ------------\n    \n      Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n    \n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n    \n      If the assimliated promise rejects, then the downstream promise will also reject.\n    \n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n    \n      Simple Example\n      --------------\n    \n      Synchronous Example\n    \n      ```javascript\n      let result;\n    \n      try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n    \n      Errback Example\n    \n      ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n    \n      Promise Example;\n    \n      ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n    \n      Advanced Example\n      --------------\n    \n      Synchronous Example\n    \n      ```javascript\n      let author, books;\n    \n      try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n    \n      Errback Example\n    \n      ```js\n    \n      function foundBooks(books) {\n    \n      }\n    \n      function failure(reason) {\n    \n      }\n    \n      findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n    \n      Promise Example;\n    \n      ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n    \n      @method then\n      @param {Function} onFulfilled\n      @param {Function} onRejected\n      Useful for tooling.\n      @return {Promise}\n    */\n    then: then,\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n    \n      ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n    \n      // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n    \n      // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n    \n      @method catch\n      @param {Function} onRejection\n      Useful for tooling.\n      @return {Promise}\n    */\n    'catch': function _catch(onRejection) {\n      return this.then(null, onRejection);\n    }\n  };\n\n  /*global self*/\n  function polyfill$1() {\n    var local = undefined;\n\n    if (typeof global !== 'undefined') {\n      local = global;\n    } else if (typeof self !== 'undefined') {\n      local = self;\n    } else {\n      try {\n        local = Function('return this')();\n      } catch (e) {\n        throw new Error('polyfill failed because global object is unavailable in this environment');\n      }\n    }\n\n    var P = local.Promise;\n\n    if (P) {\n      var promiseToString = null;\n      try {\n        promiseToString = Object.prototype.toString.call(P.resolve());\n      } catch (e) {\n        // silently ignored\n      }\n\n      if (promiseToString === '[object Promise]' && !P.cast) {\n        return;\n      }\n    }\n\n    local.Promise = Promise$2;\n  }\n\n  // Strange compat..\n  Promise$2.polyfill = polyfill$1;\n  Promise$2.Promise = Promise$2;\n\n  return Promise$2;\n});\n\n//# sourceMappingURL=es6-promise.map\n\n//# sourceURL=webpack://Contentstack/./node_modules/es6-promise/dist/es6-promise.js?");

/***/ }),

/***/ "./node_modules/localStorage/lib/localStorage.js":
/*!*******************************************************!*\
  !*** ./node_modules/localStorage/lib/localStorage.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// http://www.rajdeepd.com/articles/chrome/localstrg/LocalStorageSample.htm\n\n// NOTE:\n// this varies from actual localStorage in some subtle ways\n\n// also, there is no persistence\n// TODO persist\n(function () {\n  \"use strict\";\n\n  var db;\n\n  function LocalStorage() {}\n  db = LocalStorage;\n\n  db.prototype.getItem = function (key) {\n    if (this.hasOwnProperty(key)) {\n      return String(this[key]);\n    }\n    return null;\n  };\n\n  db.prototype.setItem = function (key, val) {\n    this[key] = String(val);\n  };\n\n  db.prototype.removeItem = function (key) {\n    delete this[key];\n  };\n\n  db.prototype.clear = function () {\n    var self = this;\n    Object.keys(self).forEach(function (key) {\n      self[key] = undefined;\n      delete self[key];\n    });\n  };\n\n  db.prototype.key = function (i) {\n    i = i || 0;\n    return Object.keys(this)[i];\n  };\n\n  db.prototype.__defineGetter__('length', function () {\n    return Object.keys(this).length;\n  });\n\n  if (global.localStorage) {\n    module.exports = localStorage;\n  } else {\n    module.exports = new LocalStorage();\n  }\n})();\n\n//# sourceURL=webpack://Contentstack/./node_modules/localStorage/lib/localStorage.js?");

/***/ }),

/***/ "./node_modules/node-fetch/lib/index.mjs":
/*!***********************************************!*\
  !*** ./node_modules/node-fetch/lib/index.mjs ***!
  \***********************************************/
/*! exports provided: default, Headers, Request, Response, FetchError */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Headers\", function() { return Headers; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Request\", function() { return Request; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Response\", function() { return Response; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FetchError\", function() { return FetchError; });\n/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ \"stream\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! url */ \"url\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! zlib */ \"zlib\");\n\n\n\n\n\n\n// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js\n\n// fix for \"Readable\" isn't a named export issue\nconst Readable = stream__WEBPACK_IMPORTED_MODULE_0__.Readable;\n\nconst BUFFER = Symbol('buffer');\nconst TYPE = Symbol('type');\n\nclass Blob {\n\tconstructor() {\n\t\tthis[TYPE] = '';\n\n\t\tconst blobParts = arguments[0];\n\t\tconst options = arguments[1];\n\n\t\tconst buffers = [];\n\t\tlet size = 0;\n\n\t\tif (blobParts) {\n\t\t\tconst a = blobParts;\n\t\t\tconst length = Number(a.length);\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tconst element = a[i];\n\t\t\t\tlet buffer;\n\t\t\t\tif (element instanceof Buffer) {\n\t\t\t\t\tbuffer = element;\n\t\t\t\t} else if (ArrayBuffer.isView(element)) {\n\t\t\t\t\tbuffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);\n\t\t\t\t} else if (element instanceof ArrayBuffer) {\n\t\t\t\t\tbuffer = Buffer.from(element);\n\t\t\t\t} else if (element instanceof Blob) {\n\t\t\t\t\tbuffer = element[BUFFER];\n\t\t\t\t} else {\n\t\t\t\t\tbuffer = Buffer.from(typeof element === 'string' ? element : String(element));\n\t\t\t\t}\n\t\t\t\tsize += buffer.length;\n\t\t\t\tbuffers.push(buffer);\n\t\t\t}\n\t\t}\n\n\t\tthis[BUFFER] = Buffer.concat(buffers);\n\n\t\tlet type = options && options.type !== undefined && String(options.type).toLowerCase();\n\t\tif (type && !/[^\\u0020-\\u007E]/.test(type)) {\n\t\t\tthis[TYPE] = type;\n\t\t}\n\t}\n\tget size() {\n\t\treturn this[BUFFER].length;\n\t}\n\tget type() {\n\t\treturn this[TYPE];\n\t}\n\ttext() {\n\t\treturn Promise.resolve(this[BUFFER].toString());\n\t}\n\tarrayBuffer() {\n\t\tconst buf = this[BUFFER];\n\t\tconst ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\treturn Promise.resolve(ab);\n\t}\n\tstream() {\n\t\tconst readable = new Readable();\n\t\treadable._read = function () {};\n\t\treadable.push(this[BUFFER]);\n\t\treadable.push(null);\n\t\treturn readable;\n\t}\n\ttoString() {\n\t\treturn '[object Blob]';\n\t}\n\tslice() {\n\t\tconst size = this.size;\n\n\t\tconst start = arguments[0];\n\t\tconst end = arguments[1];\n\t\tlet relativeStart, relativeEnd;\n\t\tif (start === undefined) {\n\t\t\trelativeStart = 0;\n\t\t} else if (start < 0) {\n\t\t\trelativeStart = Math.max(size + start, 0);\n\t\t} else {\n\t\t\trelativeStart = Math.min(start, size);\n\t\t}\n\t\tif (end === undefined) {\n\t\t\trelativeEnd = size;\n\t\t} else if (end < 0) {\n\t\t\trelativeEnd = Math.max(size + end, 0);\n\t\t} else {\n\t\t\trelativeEnd = Math.min(end, size);\n\t\t}\n\t\tconst span = Math.max(relativeEnd - relativeStart, 0);\n\n\t\tconst buffer = this[BUFFER];\n\t\tconst slicedBuffer = buffer.slice(relativeStart, relativeStart + span);\n\t\tconst blob = new Blob([], { type: arguments[2] });\n\t\tblob[BUFFER] = slicedBuffer;\n\t\treturn blob;\n\t}\n}\n\nObject.defineProperties(Blob.prototype, {\n\tsize: { enumerable: true },\n\ttype: { enumerable: true },\n\tslice: { enumerable: true }\n});\n\nObject.defineProperty(Blob.prototype, Symbol.toStringTag, {\n\tvalue: 'Blob',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * fetch-error.js\n *\n * FetchError interface for operational errors\n */\n\n/**\n * Create FetchError instance\n *\n * @param   String      message      Error message for human\n * @param   String      type         Error type for machine\n * @param   String      systemError  For Node.js system error\n * @return  FetchError\n */\nfunction FetchError(message, type, systemError) {\n  Error.call(this, message);\n\n  this.message = message;\n  this.type = type;\n\n  // when err.type is `system`, err.code contains system error code\n  if (systemError) {\n    this.code = this.errno = systemError.code;\n  }\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nFetchError.prototype = Object.create(Error.prototype);\nFetchError.prototype.constructor = FetchError;\nFetchError.prototype.name = 'FetchError';\n\nlet convert;\ntry {\n\tconvert = require('encoding').convert;\n} catch (e) {}\n\nconst INTERNALS = Symbol('Body internals');\n\n// fix an issue where \"PassThrough\" isn't a named export for node <10\nconst PassThrough = stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough;\n\n/**\n * Body mixin\n *\n * Ref: https://fetch.spec.whatwg.org/#body\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nfunction Body(body) {\n\tvar _this = this;\n\n\tvar _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n\t    _ref$size = _ref.size;\n\n\tlet size = _ref$size === undefined ? 0 : _ref$size;\n\tvar _ref$timeout = _ref.timeout;\n\tlet timeout = _ref$timeout === undefined ? 0 : _ref$timeout;\n\n\tif (body == null) {\n\t\t// body is undefined or null\n\t\tbody = null;\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\tbody = Buffer.from(body.toString());\n\t} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\tbody = Buffer.from(body);\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\tbody = Buffer.from(body.buffer, body.byteOffset, body.byteLength);\n\t} else if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) ; else {\n\t\t// none of the above\n\t\t// coerce to string then buffer\n\t\tbody = Buffer.from(String(body));\n\t}\n\tthis[INTERNALS] = {\n\t\tbody,\n\t\tdisturbed: false,\n\t\terror: null\n\t};\n\tthis.size = size;\n\tthis.timeout = timeout;\n\n\tif (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) {\n\t\tbody.on('error', function (err) {\n\t\t\tconst error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);\n\t\t\t_this[INTERNALS].error = error;\n\t\t});\n\t}\n}\n\nBody.prototype = {\n\tget body() {\n\t\treturn this[INTERNALS].body;\n\t},\n\n\tget bodyUsed() {\n\t\treturn this[INTERNALS].disturbed;\n\t},\n\n\t/**\n  * Decode response as ArrayBuffer\n  *\n  * @return  Promise\n  */\n\tarrayBuffer() {\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n\t\t});\n\t},\n\n\t/**\n  * Return raw response as Blob\n  *\n  * @return Promise\n  */\n\tblob() {\n\t\tlet ct = this.headers && this.headers.get('content-type') || '';\n\t\treturn consumeBody.call(this).then(function (buf) {\n\t\t\treturn Object.assign(\n\t\t\t// Prevent copying\n\t\t\tnew Blob([], {\n\t\t\t\ttype: ct.toLowerCase()\n\t\t\t}), {\n\t\t\t\t[BUFFER]: buf\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n  * Decode response as json\n  *\n  * @return  Promise\n  */\n\tjson() {\n\t\tvar _this2 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(buffer.toString());\n\t\t\t} catch (err) {\n\t\t\t\treturn Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n  * Decode response as text\n  *\n  * @return  Promise\n  */\n\ttext() {\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn buffer.toString();\n\t\t});\n\t},\n\n\t/**\n  * Decode response as buffer (non-spec api)\n  *\n  * @return  Promise\n  */\n\tbuffer() {\n\t\treturn consumeBody.call(this);\n\t},\n\n\t/**\n  * Decode response as text, while automatically detecting the encoding and\n  * trying to decode to UTF-8 (non-spec api)\n  *\n  * @return  Promise\n  */\n\ttextConverted() {\n\t\tvar _this3 = this;\n\n\t\treturn consumeBody.call(this).then(function (buffer) {\n\t\t\treturn convertBody(buffer, _this3.headers);\n\t\t});\n\t}\n};\n\n// In browsers, all properties are enumerable.\nObject.defineProperties(Body.prototype, {\n\tbody: { enumerable: true },\n\tbodyUsed: { enumerable: true },\n\tarrayBuffer: { enumerable: true },\n\tblob: { enumerable: true },\n\tjson: { enumerable: true },\n\ttext: { enumerable: true }\n});\n\nBody.mixIn = function (proto) {\n\tfor (const name of Object.getOwnPropertyNames(Body.prototype)) {\n\t\t// istanbul ignore else: future proof\n\t\tif (!(name in proto)) {\n\t\t\tconst desc = Object.getOwnPropertyDescriptor(Body.prototype, name);\n\t\t\tObject.defineProperty(proto, name, desc);\n\t\t}\n\t}\n};\n\n/**\n * Consume and convert an entire Body to a Buffer.\n *\n * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body\n *\n * @return  Promise\n */\nfunction consumeBody() {\n\tvar _this4 = this;\n\n\tif (this[INTERNALS].disturbed) {\n\t\treturn Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));\n\t}\n\n\tthis[INTERNALS].disturbed = true;\n\n\tif (this[INTERNALS].error) {\n\t\treturn Body.Promise.reject(this[INTERNALS].error);\n\t}\n\n\tlet body = this.body;\n\n\t// body is null\n\tif (body === null) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is blob\n\tif (isBlob(body)) {\n\t\tbody = body.stream();\n\t}\n\n\t// body is buffer\n\tif (Buffer.isBuffer(body)) {\n\t\treturn Body.Promise.resolve(body);\n\t}\n\n\t// istanbul ignore if: should never happen\n\tif (!(body instanceof stream__WEBPACK_IMPORTED_MODULE_0__)) {\n\t\treturn Body.Promise.resolve(Buffer.alloc(0));\n\t}\n\n\t// body is stream\n\t// get ready to actually consume the body\n\tlet accum = [];\n\tlet accumBytes = 0;\n\tlet abort = false;\n\n\treturn new Body.Promise(function (resolve, reject) {\n\t\tlet resTimeout;\n\n\t\t// allow timeout on slow response body\n\t\tif (_this4.timeout) {\n\t\t\tresTimeout = setTimeout(function () {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));\n\t\t\t}, _this4.timeout);\n\t\t}\n\n\t\t// handle stream errors\n\t\tbody.on('error', function (err) {\n\t\t\tif (err.name === 'AbortError') {\n\t\t\t\t// if the request was aborted, reject with this Error\n\t\t\t\tabort = true;\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\t// other errors, such as incorrect content-encoding\n\t\t\t\treject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\n\t\tbody.on('data', function (chunk) {\n\t\t\tif (abort || chunk === null) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (_this4.size && accumBytes + chunk.length > _this4.size) {\n\t\t\t\tabort = true;\n\t\t\t\treject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\taccumBytes += chunk.length;\n\t\t\taccum.push(chunk);\n\t\t});\n\n\t\tbody.on('end', function () {\n\t\t\tif (abort) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tclearTimeout(resTimeout);\n\n\t\t\ttry {\n\t\t\t\tresolve(Buffer.concat(accum, accumBytes));\n\t\t\t} catch (err) {\n\t\t\t\t// handle streams that have accumulated too much data (issue #414)\n\t\t\t\treject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Detect buffer encoding and convert to target encoding\n * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding\n *\n * @param   Buffer  buffer    Incoming buffer\n * @param   String  encoding  Target encoding\n * @return  String\n */\nfunction convertBody(buffer, headers) {\n\tif (typeof convert !== 'function') {\n\t\tthrow new Error('The package `encoding` must be installed to use the textConverted() function');\n\t}\n\n\tconst ct = headers.get('content-type');\n\tlet charset = 'utf-8';\n\tlet res, str;\n\n\t// header\n\tif (ct) {\n\t\tres = /charset=([^;]*)/i.exec(ct);\n\t}\n\n\t// no charset in content type, peek at response body for at most 1024 bytes\n\tstr = buffer.slice(0, 1024).toString();\n\n\t// html5\n\tif (!res && str) {\n\t\tres = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// html4\n\tif (!res && str) {\n\t\tres = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n\t\tif (!res) {\n\t\t\tres = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n\t\t\tif (res) {\n\t\t\t\tres.pop(); // drop last quote\n\t\t\t}\n\t\t}\n\n\t\tif (res) {\n\t\t\tres = /charset=(.*)/i.exec(res.pop());\n\t\t}\n\t}\n\n\t// xml\n\tif (!res && str) {\n\t\tres = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n\t}\n\n\t// found charset\n\tif (res) {\n\t\tcharset = res.pop();\n\n\t\t// prevent decode issues when sites use incorrect encoding\n\t\t// ref: https://hsivonen.fi/encoding-menu/\n\t\tif (charset === 'gb2312' || charset === 'gbk') {\n\t\t\tcharset = 'gb18030';\n\t\t}\n\t}\n\n\t// turn raw buffers into a single utf-8 buffer\n\treturn convert(buffer, 'UTF-8', charset).toString();\n}\n\n/**\n * Detect a URLSearchParams object\n * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143\n *\n * @param   Object  obj     Object to detect by type or brand\n * @return  String\n */\nfunction isURLSearchParams(obj) {\n\t// Duck-typing as a necessary condition.\n\tif (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {\n\t\treturn false;\n\t}\n\n\t// Brand-checking and more duck-typing as optional condition.\n\treturn obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\n}\n\n/**\n * Check if `obj` is a W3C `Blob` object (which `File` inherits from)\n * @param  {*} obj\n * @return {boolean}\n */\nfunction isBlob(obj) {\n\treturn typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\n}\n\n/**\n * Clone body given Res/Req instance\n *\n * @param   Mixed  instance  Response or Request instance\n * @return  Mixed\n */\nfunction clone(instance) {\n\tlet p1, p2;\n\tlet body = instance.body;\n\n\t// don't allow cloning a used body\n\tif (instance.bodyUsed) {\n\t\tthrow new Error('cannot clone body after it is used');\n\t}\n\n\t// check that body is a stream and not form-data object\n\t// note: we can't clone the form-data object without having it as a dependency\n\tif (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__ && typeof body.getBoundary !== 'function') {\n\t\t// tee instance body\n\t\tp1 = new PassThrough();\n\t\tp2 = new PassThrough();\n\t\tbody.pipe(p1);\n\t\tbody.pipe(p2);\n\t\t// set instance body to teed body and return the other teed body\n\t\tinstance[INTERNALS].body = p1;\n\t\tbody = p2;\n\t}\n\n\treturn body;\n}\n\n/**\n * Performs the operation \"extract a `Content-Type` value from |object|\" as\n * specified in the specification:\n * https://fetch.spec.whatwg.org/#concept-bodyinit-extract\n *\n * This function assumes that instance.body is present.\n *\n * @param   Mixed  instance  Any options.body input\n */\nfunction extractContentType(body) {\n\tif (body === null) {\n\t\t// body is null\n\t\treturn null;\n\t} else if (typeof body === 'string') {\n\t\t// body is string\n\t\treturn 'text/plain;charset=UTF-8';\n\t} else if (isURLSearchParams(body)) {\n\t\t// body is a URLSearchParams\n\t\treturn 'application/x-www-form-urlencoded;charset=UTF-8';\n\t} else if (isBlob(body)) {\n\t\t// body is blob\n\t\treturn body.type || null;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn null;\n\t} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {\n\t\t// body is ArrayBuffer\n\t\treturn null;\n\t} else if (ArrayBuffer.isView(body)) {\n\t\t// body is ArrayBufferView\n\t\treturn null;\n\t} else if (typeof body.getBoundary === 'function') {\n\t\t// detect form data input from form-data module\n\t\treturn `multipart/form-data;boundary=${body.getBoundary()}`;\n\t} else if (body instanceof stream__WEBPACK_IMPORTED_MODULE_0__) {\n\t\t// body is stream\n\t\t// can't really do much about this\n\t\treturn null;\n\t} else {\n\t\t// Body constructor defaults other things to string\n\t\treturn 'text/plain;charset=UTF-8';\n\t}\n}\n\n/**\n * The Fetch Standard treats this as if \"total bytes\" is a property on the body.\n * For us, we have to explicitly get it with a function.\n *\n * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes\n *\n * @param   Body    instance   Instance of Body\n * @return  Number?            Number of bytes, or null if not possible\n */\nfunction getTotalBytes(instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\treturn 0;\n\t} else if (isBlob(body)) {\n\t\treturn body.size;\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\treturn body.length;\n\t} else if (body && typeof body.getLengthSync === 'function') {\n\t\t// detect form data input from form-data module\n\t\tif (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x\n\t\tbody.hasKnownLength && body.hasKnownLength()) {\n\t\t\t// 2.x\n\t\t\treturn body.getLengthSync();\n\t\t}\n\t\treturn null;\n\t} else {\n\t\t// body is stream\n\t\treturn null;\n\t}\n}\n\n/**\n * Write a Body to a Node.js WritableStream (e.g. http.Request) object.\n *\n * @param   Body    instance   Instance of Body\n * @return  Void\n */\nfunction writeToStream(dest, instance) {\n\tconst body = instance.body;\n\n\n\tif (body === null) {\n\t\t// body is null\n\t\tdest.end();\n\t} else if (isBlob(body)) {\n\t\tbody.stream().pipe(dest);\n\t} else if (Buffer.isBuffer(body)) {\n\t\t// body is buffer\n\t\tdest.write(body);\n\t\tdest.end();\n\t} else {\n\t\t// body is stream\n\t\tbody.pipe(dest);\n\t}\n}\n\n// expose Promise\nBody.Promise = global.Promise;\n\n/**\n * headers.js\n *\n * Headers class offers convenient helpers\n */\n\nconst invalidTokenRegex = /[^\\^_`a-zA-Z\\-0-9!#$%&'*+.|~]/;\nconst invalidHeaderCharRegex = /[^\\t\\x20-\\x7e\\x80-\\xff]/;\n\nfunction validateName(name) {\n\tname = `${name}`;\n\tif (invalidTokenRegex.test(name) || name === '') {\n\t\tthrow new TypeError(`${name} is not a legal HTTP header name`);\n\t}\n}\n\nfunction validateValue(value) {\n\tvalue = `${value}`;\n\tif (invalidHeaderCharRegex.test(value)) {\n\t\tthrow new TypeError(`${value} is not a legal HTTP header value`);\n\t}\n}\n\n/**\n * Find the key in the map object given a header name.\n *\n * Returns undefined if not found.\n *\n * @param   String  name  Header name\n * @return  String|Undefined\n */\nfunction find(map, name) {\n\tname = name.toLowerCase();\n\tfor (const key in map) {\n\t\tif (key.toLowerCase() === name) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst MAP = Symbol('map');\nclass Headers {\n\t/**\n  * Headers class\n  *\n  * @param   Object  headers  Response headers\n  * @return  Void\n  */\n\tconstructor() {\n\t\tlet init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n\n\t\tthis[MAP] = Object.create(null);\n\n\t\tif (init instanceof Headers) {\n\t\t\tconst rawHeaders = init.raw();\n\t\t\tconst headerNames = Object.keys(rawHeaders);\n\n\t\t\tfor (const headerName of headerNames) {\n\t\t\t\tfor (const value of rawHeaders[headerName]) {\n\t\t\t\t\tthis.append(headerName, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// We don't worry about converting prop to ByteString here as append()\n\t\t// will handle it.\n\t\tif (init == null) ; else if (typeof init === 'object') {\n\t\t\tconst method = init[Symbol.iterator];\n\t\t\tif (method != null) {\n\t\t\t\tif (typeof method !== 'function') {\n\t\t\t\t\tthrow new TypeError('Header pairs must be iterable');\n\t\t\t\t}\n\n\t\t\t\t// sequence<sequence<ByteString>>\n\t\t\t\t// Note: per spec we have to first exhaust the lists then process them\n\t\t\t\tconst pairs = [];\n\t\t\t\tfor (const pair of init) {\n\t\t\t\t\tif (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be iterable');\n\t\t\t\t\t}\n\t\t\t\t\tpairs.push(Array.from(pair));\n\t\t\t\t}\n\n\t\t\t\tfor (const pair of pairs) {\n\t\t\t\t\tif (pair.length !== 2) {\n\t\t\t\t\t\tthrow new TypeError('Each header pair must be a name/value tuple');\n\t\t\t\t\t}\n\t\t\t\t\tthis.append(pair[0], pair[1]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// record<ByteString, ByteString>\n\t\t\t\tfor (const key of Object.keys(init)) {\n\t\t\t\t\tconst value = init[key];\n\t\t\t\t\tthis.append(key, value);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new TypeError('Provided initializer must be an object');\n\t\t}\n\t}\n\n\t/**\n  * Return combined header value given name\n  *\n  * @param   String  name  Header name\n  * @return  Mixed\n  */\n\tget(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key === undefined) {\n\t\t\treturn null;\n\t\t}\n\n\t\treturn this[MAP][key].join(', ');\n\t}\n\n\t/**\n  * Iterate over all headers\n  *\n  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\n  * @param   Boolean   thisArg   `this` context for callback function\n  * @return  Void\n  */\n\tforEach(callback) {\n\t\tlet thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n\t\tlet pairs = getHeaders(this);\n\t\tlet i = 0;\n\t\twhile (i < pairs.length) {\n\t\t\tvar _pairs$i = pairs[i];\n\t\t\tconst name = _pairs$i[0],\n\t\t\t      value = _pairs$i[1];\n\n\t\t\tcallback.call(thisArg, value, name, this);\n\t\t\tpairs = getHeaders(this);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t/**\n  * Overwrite header values given name\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tset(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tthis[MAP][key !== undefined ? key : name] = [value];\n\t}\n\n\t/**\n  * Append a value onto existing header\n  *\n  * @param   String  name   Header name\n  * @param   String  value  Header value\n  * @return  Void\n  */\n\tappend(name, value) {\n\t\tname = `${name}`;\n\t\tvalue = `${value}`;\n\t\tvalidateName(name);\n\t\tvalidateValue(value);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tthis[MAP][key].push(value);\n\t\t} else {\n\t\t\tthis[MAP][name] = [value];\n\t\t}\n\t}\n\n\t/**\n  * Check for header name existence\n  *\n  * @param   String   name  Header name\n  * @return  Boolean\n  */\n\thas(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\treturn find(this[MAP], name) !== undefined;\n\t}\n\n\t/**\n  * Delete all header values given name\n  *\n  * @param   String  name  Header name\n  * @return  Void\n  */\n\tdelete(name) {\n\t\tname = `${name}`;\n\t\tvalidateName(name);\n\t\tconst key = find(this[MAP], name);\n\t\tif (key !== undefined) {\n\t\t\tdelete this[MAP][key];\n\t\t}\n\t}\n\n\t/**\n  * Return raw headers (non-spec api)\n  *\n  * @return  Object\n  */\n\traw() {\n\t\treturn this[MAP];\n\t}\n\n\t/**\n  * Get an iterator on keys.\n  *\n  * @return  Iterator\n  */\n\tkeys() {\n\t\treturn createHeadersIterator(this, 'key');\n\t}\n\n\t/**\n  * Get an iterator on values.\n  *\n  * @return  Iterator\n  */\n\tvalues() {\n\t\treturn createHeadersIterator(this, 'value');\n\t}\n\n\t/**\n  * Get an iterator on entries.\n  *\n  * This is the default iterator of the Headers object.\n  *\n  * @return  Iterator\n  */\n\t[Symbol.iterator]() {\n\t\treturn createHeadersIterator(this, 'key+value');\n\t}\n}\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\n\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n\tvalue: 'Headers',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Headers.prototype, {\n\tget: { enumerable: true },\n\tforEach: { enumerable: true },\n\tset: { enumerable: true },\n\tappend: { enumerable: true },\n\thas: { enumerable: true },\n\tdelete: { enumerable: true },\n\tkeys: { enumerable: true },\n\tvalues: { enumerable: true },\n\tentries: { enumerable: true }\n});\n\nfunction getHeaders(headers) {\n\tlet kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';\n\n\tconst keys = Object.keys(headers[MAP]).sort();\n\treturn keys.map(kind === 'key' ? function (k) {\n\t\treturn k.toLowerCase();\n\t} : kind === 'value' ? function (k) {\n\t\treturn headers[MAP][k].join(', ');\n\t} : function (k) {\n\t\treturn [k.toLowerCase(), headers[MAP][k].join(', ')];\n\t});\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n\tconst iterator = Object.create(HeadersIteratorPrototype);\n\titerator[INTERNAL] = {\n\t\ttarget,\n\t\tkind,\n\t\tindex: 0\n\t};\n\treturn iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n\tnext() {\n\t\t// istanbul ignore if\n\t\tif (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n\t\t\tthrow new TypeError('Value of `this` is not a HeadersIterator');\n\t\t}\n\n\t\tvar _INTERNAL = this[INTERNAL];\n\t\tconst target = _INTERNAL.target,\n\t\t      kind = _INTERNAL.kind,\n\t\t      index = _INTERNAL.index;\n\n\t\tconst values = getHeaders(target, kind);\n\t\tconst len = values.length;\n\t\tif (index >= len) {\n\t\t\treturn {\n\t\t\t\tvalue: undefined,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\n\t\tthis[INTERNAL].index = index + 1;\n\n\t\treturn {\n\t\t\tvalue: values[index],\n\t\t\tdone: false\n\t\t};\n\t}\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\n\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n\tvalue: 'HeadersIterator',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\n/**\n * Export the Headers object in a form that Node.js can consume.\n *\n * @param   Headers  headers\n * @return  Object\n */\nfunction exportNodeCompatibleHeaders(headers) {\n\tconst obj = Object.assign({ __proto__: null }, headers[MAP]);\n\n\t// http.request() only supports string as Host header. This hack makes\n\t// specifying custom Host header possible.\n\tconst hostHeaderKey = find(headers[MAP], 'Host');\n\tif (hostHeaderKey !== undefined) {\n\t\tobj[hostHeaderKey] = obj[hostHeaderKey][0];\n\t}\n\n\treturn obj;\n}\n\n/**\n * Create a Headers object from an object of headers, ignoring those that do\n * not conform to HTTP grammar productions.\n *\n * @param   Object  obj  Object of headers\n * @return  Headers\n */\nfunction createHeadersLenient(obj) {\n\tconst headers = new Headers();\n\tfor (const name of Object.keys(obj)) {\n\t\tif (invalidTokenRegex.test(name)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (Array.isArray(obj[name])) {\n\t\t\tfor (const val of obj[name]) {\n\t\t\t\tif (invalidHeaderCharRegex.test(val)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (headers[MAP][name] === undefined) {\n\t\t\t\t\theaders[MAP][name] = [val];\n\t\t\t\t} else {\n\t\t\t\t\theaders[MAP][name].push(val);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (!invalidHeaderCharRegex.test(obj[name])) {\n\t\t\theaders[MAP][name] = [obj[name]];\n\t\t}\n\t}\n\treturn headers;\n}\n\nconst INTERNALS$1 = Symbol('Response internals');\n\n// fix an issue where \"STATUS_CODES\" aren't a named export for node <10\nconst STATUS_CODES = http__WEBPACK_IMPORTED_MODULE_1__.STATUS_CODES;\n\n/**\n * Response class\n *\n * @param   Stream  body  Readable stream\n * @param   Object  opts  Response options\n * @return  Void\n */\nclass Response {\n\tconstructor() {\n\t\tlet body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tlet opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tBody.call(this, body, opts);\n\n\t\tconst status = opts.status || 200;\n\t\tconst headers = new Headers(opts.headers);\n\n\t\tif (body != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(body);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tthis[INTERNALS$1] = {\n\t\t\turl: opts.url,\n\t\t\tstatus,\n\t\t\tstatusText: opts.statusText || STATUS_CODES[status],\n\t\t\theaders,\n\t\t\tcounter: opts.counter\n\t\t};\n\t}\n\n\tget url() {\n\t\treturn this[INTERNALS$1].url || '';\n\t}\n\n\tget status() {\n\t\treturn this[INTERNALS$1].status;\n\t}\n\n\t/**\n  * Convenience property representing if the request ended normally\n  */\n\tget ok() {\n\t\treturn this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;\n\t}\n\n\tget redirected() {\n\t\treturn this[INTERNALS$1].counter > 0;\n\t}\n\n\tget statusText() {\n\t\treturn this[INTERNALS$1].statusText;\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$1].headers;\n\t}\n\n\t/**\n  * Clone this response\n  *\n  * @return  Response\n  */\n\tclone() {\n\t\treturn new Response(clone(this), {\n\t\t\turl: this.url,\n\t\t\tstatus: this.status,\n\t\t\tstatusText: this.statusText,\n\t\t\theaders: this.headers,\n\t\t\tok: this.ok,\n\t\t\tredirected: this.redirected\n\t\t});\n\t}\n}\n\nBody.mixIn(Response.prototype);\n\nObject.defineProperties(Response.prototype, {\n\turl: { enumerable: true },\n\tstatus: { enumerable: true },\n\tok: { enumerable: true },\n\tredirected: { enumerable: true },\n\tstatusText: { enumerable: true },\n\theaders: { enumerable: true },\n\tclone: { enumerable: true }\n});\n\nObject.defineProperty(Response.prototype, Symbol.toStringTag, {\n\tvalue: 'Response',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nconst INTERNALS$2 = Symbol('Request internals');\n\n// fix an issue where \"format\", \"parse\" aren't a named export for node <10\nconst parse_url = url__WEBPACK_IMPORTED_MODULE_2__.parse;\nconst format_url = url__WEBPACK_IMPORTED_MODULE_2__.format;\n\nconst streamDestructionSupported = 'destroy' in stream__WEBPACK_IMPORTED_MODULE_0__.Readable.prototype;\n\n/**\n * Check if a value is an instance of Request.\n *\n * @param   Mixed   input\n * @return  Boolean\n */\nfunction isRequest(input) {\n\treturn typeof input === 'object' && typeof input[INTERNALS$2] === 'object';\n}\n\nfunction isAbortSignal(signal) {\n\tconst proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n\treturn !!(proto && proto.constructor.name === 'AbortSignal');\n}\n\n/**\n * Request class\n *\n * @param   Mixed   input  Url or Request instance\n * @param   Object  init   Custom options\n * @return  Void\n */\nclass Request {\n\tconstructor(input) {\n\t\tlet init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tlet parsedURL;\n\n\t\t// normalize input\n\t\tif (!isRequest(input)) {\n\t\t\tif (input && input.href) {\n\t\t\t\t// in order to support Node.js' Url objects; though WHATWG's URL objects\n\t\t\t\t// will fall into this branch also (since their `toString()` will return\n\t\t\t\t// `href` property anyway)\n\t\t\t\tparsedURL = parse_url(input.href);\n\t\t\t} else {\n\t\t\t\t// coerce input to a string before attempting to parse\n\t\t\t\tparsedURL = parse_url(`${input}`);\n\t\t\t}\n\t\t\tinput = {};\n\t\t} else {\n\t\t\tparsedURL = parse_url(input.url);\n\t\t}\n\n\t\tlet method = init.method || input.method || 'GET';\n\t\tmethod = method.toUpperCase();\n\n\t\tif ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {\n\t\t\tthrow new TypeError('Request with GET/HEAD method cannot have body');\n\t\t}\n\n\t\tlet inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n\n\t\tBody.call(this, inputBody, {\n\t\t\ttimeout: init.timeout || input.timeout || 0,\n\t\t\tsize: init.size || input.size || 0\n\t\t});\n\n\t\tconst headers = new Headers(init.headers || input.headers || {});\n\n\t\tif (inputBody != null && !headers.has('Content-Type')) {\n\t\t\tconst contentType = extractContentType(inputBody);\n\t\t\tif (contentType) {\n\t\t\t\theaders.append('Content-Type', contentType);\n\t\t\t}\n\t\t}\n\n\t\tlet signal = isRequest(input) ? input.signal : null;\n\t\tif ('signal' in init) signal = init.signal;\n\n\t\tif (signal != null && !isAbortSignal(signal)) {\n\t\t\tthrow new TypeError('Expected signal to be an instanceof AbortSignal');\n\t\t}\n\n\t\tthis[INTERNALS$2] = {\n\t\t\tmethod,\n\t\t\tredirect: init.redirect || input.redirect || 'follow',\n\t\t\theaders,\n\t\t\tparsedURL,\n\t\t\tsignal\n\t\t};\n\n\t\t// node-fetch-only options\n\t\tthis.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n\t\tthis.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n\t\tthis.counter = init.counter || input.counter || 0;\n\t\tthis.agent = init.agent || input.agent;\n\t}\n\n\tget method() {\n\t\treturn this[INTERNALS$2].method;\n\t}\n\n\tget url() {\n\t\treturn format_url(this[INTERNALS$2].parsedURL);\n\t}\n\n\tget headers() {\n\t\treturn this[INTERNALS$2].headers;\n\t}\n\n\tget redirect() {\n\t\treturn this[INTERNALS$2].redirect;\n\t}\n\n\tget signal() {\n\t\treturn this[INTERNALS$2].signal;\n\t}\n\n\t/**\n  * Clone this request\n  *\n  * @return  Request\n  */\n\tclone() {\n\t\treturn new Request(this);\n\t}\n}\n\nBody.mixIn(Request.prototype);\n\nObject.defineProperty(Request.prototype, Symbol.toStringTag, {\n\tvalue: 'Request',\n\twritable: false,\n\tenumerable: false,\n\tconfigurable: true\n});\n\nObject.defineProperties(Request.prototype, {\n\tmethod: { enumerable: true },\n\turl: { enumerable: true },\n\theaders: { enumerable: true },\n\tredirect: { enumerable: true },\n\tclone: { enumerable: true },\n\tsignal: { enumerable: true }\n});\n\n/**\n * Convert a Request to Node.js http request options.\n *\n * @param   Request  A Request instance\n * @return  Object   The options object to be passed to http.request\n */\nfunction getNodeRequestOptions(request) {\n\tconst parsedURL = request[INTERNALS$2].parsedURL;\n\tconst headers = new Headers(request[INTERNALS$2].headers);\n\n\t// fetch step 1.3\n\tif (!headers.has('Accept')) {\n\t\theaders.set('Accept', '*/*');\n\t}\n\n\t// Basic fetch\n\tif (!parsedURL.protocol || !parsedURL.hostname) {\n\t\tthrow new TypeError('Only absolute URLs are supported');\n\t}\n\n\tif (!/^https?:$/.test(parsedURL.protocol)) {\n\t\tthrow new TypeError('Only HTTP(S) protocols are supported');\n\t}\n\n\tif (request.signal && request.body instanceof stream__WEBPACK_IMPORTED_MODULE_0__.Readable && !streamDestructionSupported) {\n\t\tthrow new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');\n\t}\n\n\t// HTTP-network-or-cache fetch steps 2.4-2.7\n\tlet contentLengthValue = null;\n\tif (request.body == null && /^(POST|PUT)$/i.test(request.method)) {\n\t\tcontentLengthValue = '0';\n\t}\n\tif (request.body != null) {\n\t\tconst totalBytes = getTotalBytes(request);\n\t\tif (typeof totalBytes === 'number') {\n\t\t\tcontentLengthValue = String(totalBytes);\n\t\t}\n\t}\n\tif (contentLengthValue) {\n\t\theaders.set('Content-Length', contentLengthValue);\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.11\n\tif (!headers.has('User-Agent')) {\n\t\theaders.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');\n\t}\n\n\t// HTTP-network-or-cache fetch step 2.15\n\tif (request.compress && !headers.has('Accept-Encoding')) {\n\t\theaders.set('Accept-Encoding', 'gzip,deflate');\n\t}\n\n\tlet agent = request.agent;\n\tif (typeof agent === 'function') {\n\t\tagent = agent(parsedURL);\n\t}\n\n\tif (!headers.has('Connection') && !agent) {\n\t\theaders.set('Connection', 'close');\n\t}\n\n\t// HTTP-network fetch step 4.2\n\t// chunked encoding is handled by Node.js\n\n\treturn Object.assign({}, parsedURL, {\n\t\tmethod: request.method,\n\t\theaders: exportNodeCompatibleHeaders(headers),\n\t\tagent\n\t});\n}\n\n/**\n * abort-error.js\n *\n * AbortError interface for cancelled requests\n */\n\n/**\n * Create AbortError instance\n *\n * @param   String      message      Error message for human\n * @return  AbortError\n */\nfunction AbortError(message) {\n  Error.call(this, message);\n\n  this.type = 'aborted';\n  this.message = message;\n\n  // hide custom error implementation details from end-users\n  Error.captureStackTrace(this, this.constructor);\n}\n\nAbortError.prototype = Object.create(Error.prototype);\nAbortError.prototype.constructor = AbortError;\nAbortError.prototype.name = 'AbortError';\n\n// fix an issue where \"PassThrough\", \"resolve\" aren't a named export for node <10\nconst PassThrough$1 = stream__WEBPACK_IMPORTED_MODULE_0__.PassThrough;\nconst resolve_url = url__WEBPACK_IMPORTED_MODULE_2__.resolve;\n\n/**\n * Fetch function\n *\n * @param   Mixed    url   Absolute url or Request instance\n * @param   Object   opts  Fetch options\n * @return  Promise\n */\nfunction fetch(url, opts) {\n\n\t// allow custom promise\n\tif (!fetch.Promise) {\n\t\tthrow new Error('native promise missing, set fetch.Promise to your favorite alternative');\n\t}\n\n\tBody.Promise = fetch.Promise;\n\n\t// wrap http.request into fetch\n\treturn new fetch.Promise(function (resolve, reject) {\n\t\t// build request object\n\t\tconst request = new Request(url, opts);\n\t\tconst options = getNodeRequestOptions(request);\n\n\t\tconst send = (options.protocol === 'https:' ? https__WEBPACK_IMPORTED_MODULE_3__ : http__WEBPACK_IMPORTED_MODULE_1__).request;\n\t\tconst signal = request.signal;\n\n\t\tlet response = null;\n\n\t\tconst abort = function abort() {\n\t\t\tlet error = new AbortError('The user aborted a request.');\n\t\t\treject(error);\n\t\t\tif (request.body && request.body instanceof stream__WEBPACK_IMPORTED_MODULE_0__.Readable) {\n\t\t\t\trequest.body.destroy(error);\n\t\t\t}\n\t\t\tif (!response || !response.body) return;\n\t\t\tresponse.body.emit('error', error);\n\t\t};\n\n\t\tif (signal && signal.aborted) {\n\t\t\tabort();\n\t\t\treturn;\n\t\t}\n\n\t\tconst abortAndFinalize = function abortAndFinalize() {\n\t\t\tabort();\n\t\t\tfinalize();\n\t\t};\n\n\t\t// send request\n\t\tconst req = send(options);\n\t\tlet reqTimeout;\n\n\t\tif (signal) {\n\t\t\tsignal.addEventListener('abort', abortAndFinalize);\n\t\t}\n\n\t\tfunction finalize() {\n\t\t\treq.abort();\n\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\tclearTimeout(reqTimeout);\n\t\t}\n\n\t\tif (request.timeout) {\n\t\t\treq.once('socket', function (socket) {\n\t\t\t\treqTimeout = setTimeout(function () {\n\t\t\t\t\treject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));\n\t\t\t\t\tfinalize();\n\t\t\t\t}, request.timeout);\n\t\t\t});\n\t\t}\n\n\t\treq.on('error', function (err) {\n\t\t\treject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));\n\t\t\tfinalize();\n\t\t});\n\n\t\treq.on('response', function (res) {\n\t\t\tclearTimeout(reqTimeout);\n\n\t\t\tconst headers = createHeadersLenient(res.headers);\n\n\t\t\t// HTTP fetch step 5\n\t\t\tif (fetch.isRedirect(res.statusCode)) {\n\t\t\t\t// HTTP fetch step 5.2\n\t\t\t\tconst location = headers.get('Location');\n\n\t\t\t\t// HTTP fetch step 5.3\n\t\t\t\tconst locationURL = location === null ? null : resolve_url(request.url, location);\n\n\t\t\t\t// HTTP fetch step 5.5\n\t\t\t\tswitch (request.redirect) {\n\t\t\t\t\tcase 'error':\n\t\t\t\t\t\treject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t\tcase 'manual':\n\t\t\t\t\t\t// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.\n\t\t\t\t\t\tif (locationURL !== null) {\n\t\t\t\t\t\t\t// handle corrupted header\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\theaders.set('Location', locationURL);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\t// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'follow':\n\t\t\t\t\t\t// HTTP-redirect fetch step 2\n\t\t\t\t\t\tif (locationURL === null) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 5\n\t\t\t\t\t\tif (request.counter >= request.follow) {\n\t\t\t\t\t\t\treject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 6 (counter increment)\n\t\t\t\t\t\t// Create a new Request object.\n\t\t\t\t\t\tconst requestOpts = {\n\t\t\t\t\t\t\theaders: new Headers(request.headers),\n\t\t\t\t\t\t\tfollow: request.follow,\n\t\t\t\t\t\t\tcounter: request.counter + 1,\n\t\t\t\t\t\t\tagent: request.agent,\n\t\t\t\t\t\t\tcompress: request.compress,\n\t\t\t\t\t\t\tmethod: request.method,\n\t\t\t\t\t\t\tbody: request.body,\n\t\t\t\t\t\t\tsignal: request.signal,\n\t\t\t\t\t\t\ttimeout: request.timeout,\n\t\t\t\t\t\t\tsize: request.size\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 9\n\t\t\t\t\t\tif (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {\n\t\t\t\t\t\t\treject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));\n\t\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 11\n\t\t\t\t\t\tif (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {\n\t\t\t\t\t\t\trequestOpts.method = 'GET';\n\t\t\t\t\t\t\trequestOpts.body = undefined;\n\t\t\t\t\t\t\trequestOpts.headers.delete('content-length');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// HTTP-redirect fetch step 15\n\t\t\t\t\t\tresolve(fetch(new Request(locationURL, requestOpts)));\n\t\t\t\t\t\tfinalize();\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// prepare response\n\t\t\tres.once('end', function () {\n\t\t\t\tif (signal) signal.removeEventListener('abort', abortAndFinalize);\n\t\t\t});\n\t\t\tlet body = res.pipe(new PassThrough$1());\n\n\t\t\tconst response_options = {\n\t\t\t\turl: request.url,\n\t\t\t\tstatus: res.statusCode,\n\t\t\t\tstatusText: res.statusMessage,\n\t\t\t\theaders: headers,\n\t\t\t\tsize: request.size,\n\t\t\t\ttimeout: request.timeout,\n\t\t\t\tcounter: request.counter\n\t\t\t};\n\n\t\t\t// HTTP-network fetch step 12.1.1.3\n\t\t\tconst codings = headers.get('Content-Encoding');\n\n\t\t\t// HTTP-network fetch step 12.1.1.4: handle content codings\n\n\t\t\t// in following scenarios we ignore compression support\n\t\t\t// 1. compression support is disabled\n\t\t\t// 2. HEAD request\n\t\t\t// 3. no Content-Encoding header\n\t\t\t// 4. no content response (204)\n\t\t\t// 5. content not modified response (304)\n\t\t\tif (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// For Node v6+\n\t\t\t// Be less strict when decoding compressed responses, since sometimes\n\t\t\t// servers send slightly invalid responses that are still accepted\n\t\t\t// by common browsers.\n\t\t\t// Always using Z_SYNC_FLUSH is what cURL does.\n\t\t\tconst zlibOptions = {\n\t\t\t\tflush: zlib__WEBPACK_IMPORTED_MODULE_4__.Z_SYNC_FLUSH,\n\t\t\t\tfinishFlush: zlib__WEBPACK_IMPORTED_MODULE_4__.Z_SYNC_FLUSH\n\t\t\t};\n\n\t\t\t// for gzip\n\t\t\tif (codings == 'gzip' || codings == 'x-gzip') {\n\t\t\t\tbody = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_4__.createGunzip(zlibOptions));\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for deflate\n\t\t\tif (codings == 'deflate' || codings == 'x-deflate') {\n\t\t\t\t// handle the infamous raw deflate response from old servers\n\t\t\t\t// a hack for old IIS and Apache servers\n\t\t\t\tconst raw = res.pipe(new PassThrough$1());\n\t\t\t\traw.once('data', function (chunk) {\n\t\t\t\t\t// see http://stackoverflow.com/questions/37519828\n\t\t\t\t\tif ((chunk[0] & 0x0F) === 0x08) {\n\t\t\t\t\t\tbody = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_4__.createInflate());\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbody = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_4__.createInflateRaw());\n\t\t\t\t\t}\n\t\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\t\tresolve(response);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// for br\n\t\t\tif (codings == 'br' && typeof zlib__WEBPACK_IMPORTED_MODULE_4__.createBrotliDecompress === 'function') {\n\t\t\t\tbody = body.pipe(zlib__WEBPACK_IMPORTED_MODULE_4__.createBrotliDecompress());\n\t\t\t\tresponse = new Response(body, response_options);\n\t\t\t\tresolve(response);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, use response as-is\n\t\t\tresponse = new Response(body, response_options);\n\t\t\tresolve(response);\n\t\t});\n\n\t\twriteToStream(req, request);\n\t});\n}\n/**\n * Redirect code matching\n *\n * @param   Number   code  Status code\n * @return  Boolean\n */\nfetch.isRedirect = function (code) {\n\treturn code === 301 || code === 302 || code === 303 || code === 307 || code === 308;\n};\n\n// expose Promise\nfetch.Promise = global.Promise;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (fetch);\n\n\n\n//# sourceURL=webpack://Contentstack/./node_modules/node-fetch/lib/index.mjs?");

/***/ }),

/***/ "./src/core/cache-provider/index.js":
/*!******************************************!*\
  !*** ./src/core/cache-provider/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _localstorage = __webpack_require__(/*! ./localstorage */ \"./src/core/cache-provider/localstorage.js\");\n\nvar _localstorage2 = _interopRequireDefault(_localstorage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar CacheProvider = {};\n\nCacheProvider.providers = function (provider) {\n    if (provider) {\n        return _localstorage2.default;\n    } else {\n        console.error(\"Kindly provide valid provider.\");\n    }\n};\n\nCacheProvider.policies = {\n    IGNORE_CACHE: -1,\n    ONLY_NETWORK: 0,\n    CACHE_ELSE_NETWORK: 1,\n    NETWORK_ELSE_CACHE: 2,\n    CACHE_THEN_NETWORK: 3\n};\n\nexports.default = CacheProvider;\n\n//# sourceURL=webpack://Contentstack/./src/core/cache-provider/index.js?");

/***/ }),

/***/ "./src/core/cache-provider/localstorage.js":
/*!*************************************************!*\
  !*** ./src/core/cache-provider/localstorage.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _cache = __webpack_require__(/*! ./../cache */ \"./src/core/cache.js\");\n\nvar cache = _interopRequireWildcard(_cache);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nvar localStorage = {};\n\nlocalStorage.get = function (key, callback) {\n    try {\n        callback(null, cache.get(key));\n    } catch (e) {\n        callback(e);\n    }\n};\n\nlocalStorage.set = function (key, value, callback) {\n    try {\n        if (key && value) cache.set(key, value);\n        callback();\n    } catch (e) {\n        callback(e);\n    }\n};\n\nfunction clearValuesForKey(keyArray, append) {\n    if (!append && keyArray && keyArray.length) keyArray.push('');\n    var _key = void 0,\n        keys = cache.getKeys(),\n        storage = cache.getStorage();\n    if (!keyArray || !keyArray.length) {\n        for (var i = 0, _i = keys.length; i < _i; i++) {\n            delete storage[keys[i]];\n        }\n    } else {\n        _key = keyArray.join('.');\n        for (var _i2 = 0, _i3 = keys.length; _i2 < _i3; _i2++) {\n            if (keys[_i2] && keys[_i2].indexOf(_key) === 0) delete storage[keys[_i2]];\n        }\n    }\n}\n\nlocalStorage.clearByContentType = function () {\n    try {\n        if (arguments.length === 2 || arguments.length === 3) {\n            var args = Array.prototype.slice.call(arguments);\n            var _callback = args.splice(-1, 1).pop();\n            var valueArray = [];\n            valueArray.push.apply(valueArray, args);\n            clearValuesForKey(valueArray);\n            _callback();\n        }\n    } catch (e) {\n        callback(e);\n    }\n};\n\nlocalStorage.clearByQuery = function (query, callback) {\n    try {\n        var keys = cache.getKeys(),\n            storage = cache.getStorage();\n        for (var i = 0, _i = keys.length; i < _i; i++) {\n            if (keys[i] && ~keys[i].indexOf(query)) delete storage[keys[i]];\n        }\n        callback();\n    } catch (e) {\n        callback(e);\n    }\n};\n\nlocalStorage.clearAll = function (callback) {\n    try {\n        clearValuesForKey();\n        callback();\n    } catch (e) {\n        callback(e);\n    }\n};\n\nexports.default = localStorage;\n\n//# sourceURL=webpack://Contentstack/./src/core/cache-provider/localstorage.js?");

/***/ }),

/***/ "./src/core/cache.js":
/*!***************************!*\
  !*** ./src/core/cache.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.get = get;\nexports.set = set;\nexports.getStorage = getStorage;\nexports.getKeys = getKeys;\n\nvar _utils = __webpack_require__(/*! ./lib/utils.js */ \"./src/core/lib/utils.js\");\n\nvar Utils = _interopRequireWildcard(_utils);\n\nvar _localstorage = __webpack_require__(/*! runtime/localstorage.js */ \"./src/runtime/node/localstorage.js\");\n\nvar _localstorage2 = _interopRequireDefault(_localstorage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction get(key) {\n    var data = _localstorage2.default.getItem(key);\n    try {\n        data = JSON.parse(data);\n    } catch (e) {\n        return data;\n    }\n    return data || null;\n};\n\nfunction set(key, data) {\n    try {\n        if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {\n            _localstorage2.default.setItem(key, JSON.stringify(data));\n        } else {\n            _localstorage2.default.setItem(key, data);\n        }\n    } catch (error) {}\n};\n\nfunction getStorage() {\n    return _localstorage2.default || null;\n};\n\nfunction getKeys() {\n    return _localstorage2.default ? Object.keys(_localstorage2.default) : [];\n};\n\n//# sourceURL=webpack://Contentstack/./src/core/cache.js?");

/***/ }),

/***/ "./src/core/contentstack.js":
/*!**********************************!*\
  !*** ./src/core/contentstack.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _stack = __webpack_require__(/*! ./stack */ \"./src/core/stack.js\");\n\nvar _stack2 = _interopRequireDefault(_stack);\n\nvar _index = __webpack_require__(/*! ./cache-provider/index */ \"./src/core/cache-provider/index.js\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _contentstackregion = __webpack_require__(/*! ./contentstackregion */ \"./src/core/contentstackregion.js\");\n\nvar _contentstackregion2 = _interopRequireDefault(_contentstackregion);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n* @class \n Contentstack \n* @description Creates an instance of `Contentstack`.\n* @instance\n*/\n\nvar Contentstack = function () {\n\tfunction Contentstack() {\n\t\t_classCallCheck(this, Contentstack);\n\n\t\t/**\n   * @memberOf Contentstack\n   * @description CachePolicy contains different cache policies constants.\n   * @example\n   * Contentstack.CachePolicy.IGNORE_CACHE\n   * Contentstack.CachePolicy.ONLY_NETWORK\n   * Contentstack.CachePolicy.CACHE_ELSE_NETWORK\n   * Contentstack.CachePolicy.NETWORK_ELSE_CACHE\n   * Contentstack.CachePolicy.CACHE_THEN_NETWORK\n   */\n\t\tthis.CachePolicy = _index2.default.policies;\n\t\tthis.Region = _contentstackregion2.default;\n\t}\n\t/**\n \n * @memberOf Contentstack\n */\n\n\n\t_createClass(Contentstack, [{\n\t\tkey: \"Stack\",\n\t\tvalue: function Stack() {\n\t\t\tfor (var _len = arguments.length, stack_arguments = Array(_len), _key = 0; _key < _len; _key++) {\n\t\t\t\tstack_arguments[_key] = arguments[_key];\n\t\t\t}\n\n\t\t\treturn new (Function.prototype.bind.apply(_stack2.default, [null].concat(stack_arguments)))();\n\t\t}\n\t}]);\n\n\treturn Contentstack;\n}();\n\nmodule.exports = new Contentstack();\n\n//# sourceURL=webpack://Contentstack/./src/core/contentstack.js?");

/***/ }),

/***/ "./src/core/contentstackregion.js":
/*!****************************************!*\
  !*** ./src/core/contentstackregion.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar ContentstackRegion = {\n    EU: \"eu\",\n    US: \"us\"\n};\n\nexports.default = ContentstackRegion;\n//module.exports = ContentstackRegion;\n\n//# sourceURL=webpack://Contentstack/./src/core/contentstackregion.js?");

/***/ }),

/***/ "./src/core/lib/request.js":
/*!*********************************!*\
  !*** ./src/core/lib/request.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = Request;\n\nvar _utils = __webpack_require__(/*! ./utils.js */ \"./src/core/lib/utils.js\");\n\nvar Utils = _interopRequireWildcard(_utils);\n\nvar _http = __webpack_require__(/*! runtime/http.js */ \"./src/runtime/node/http.js\");\n\nvar _http2 = _interopRequireDefault(_http);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n//JS SDK version\nvar version = '3.11.0';\nvar environment = void 0,\n    api_key = void 0;\nfunction Request(options, fetchOptions) {\n    return new Promise(function (resolve, reject) {\n        var queryParams = void 0;\n        var serialize = function serialize(obj, prefix) {\n\n            var str = [],\n                p = void 0;\n            if ((typeof obj === \"undefined\" ? \"undefined\" : _typeof(obj)) === \"object\" && obj.length !== undefined) {\n                for (var i = 0, _i = obj.length; i < _i; i++) {\n                    str.push(prefix + '[]=' + obj[i]);\n                }\n            } else {\n                for (p in obj) {\n                    var k = prefix ? prefix + \"[\" + p + \"]\" : p,\n                        v = obj[p];\n                    str.push(v !== null && (typeof v === \"undefined\" ? \"undefined\" : _typeof(v)) === \"object\" && p !== 'query' ? serialize(v, k) : k + \"=\" + encodeURIComponent(p !== 'query' ? v : JSON.stringify(v)));\n                }\n            }\n            return str.join(\"&\");\n        };\n\n        var url = options.url,\n            headers = options.headers;\n\n        // setting headers\n        headers['Content-Type'] = 'application/json; charset=UTF-8';\n        headers['X-User-Agent'] = 'contentstack-nodejs/' + version;\n\n        if (options.body && _typeof(options.body) === 'object') {\n            delete options.body._method;\n            if (_typeof(options.body.query) === \"object\" && Object.keys(options.body.query).length === 0) delete options.body.query;\n            queryParams = serialize(options.body);\n        }\n\n        return fetchRetry(url + '?' + queryParams, headers, fetchOptions.retryDelay, fetchOptions.retryLimit, fetchOptions, resolve, reject);\n    });\n}\n\nfunction wait(retryDelay) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, retryDelay);\n    });\n}\n\nfunction fetchRetry(url, headers) {\n    var retryDelay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;\n    var retryLimit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;\n    var fetchOptions = arguments[4];\n    var resolve = arguments[5];\n    var reject = arguments[6];\n\n    var option = Object.assign({\n        method: 'GET',\n        headers: headers,\n        timeout: 3000\n    }, fetchOptions);\n\n    function onError(error) {\n        if (retryLimit === 0) {\n            reject(error);\n        } else {\n            var msDelay = retryDelay;\n            retryLimit = retryLimit - 1;\n            var retryCount = fetchOptions.retryLimit - retryLimit;\n            if (fetchOptions.retryDelayOptions) {\n                if (fetchOptions.retryDelayOptions.base) {\n                    msDelay = fetchOptions.retryDelayOptions.base * retryCount;\n                } else if (fetchOptions.retryDelayOptions.customBackoff) {\n                    msDelay = fetchOptions.retryDelayOptions.customBackoff(retryCount, error);\n                }\n            }\n            wait(msDelay).then(function () {\n                return fetchRetry(url, headers, retryDelay, retryLimit, fetchOptions, resolve, reject);\n            });\n        }\n    }\n    (0, _http2.default)(url, option).then(function (response) {\n        var data = response.json();\n        if (response.ok && response.status === 200) {\n            resolve(data);\n        } else {\n            data.then(function (json) {\n                if (fetchOptions.retryCondition && fetchOptions.retryCondition(response)) {\n                    onError(json);\n                } else {\n                    reject(json);\n                }\n            });\n        }\n    }).catch(function (error) {\n        reject(error);\n    });\n}\n\n//# sourceURL=webpack://Contentstack/./src/core/lib/request.js?");

/***/ }),

/***/ "./src/core/lib/utils.js":
/*!*******************************!*\
  !*** ./src/core/lib/utils.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.transform = transform;\nexports._type = _type;\nexports.mergeDeep = mergeDeep;\nexports.merge = merge;\nexports.isBrowser = isBrowser;\nexports.parseQueryFromParams = parseQueryFromParams;\nexports.getHash = getHash;\nexports.generateHash = generateHash;\nexports.resultWrapper = resultWrapper;\nexports.spreadResult = spreadResult;\nexports.sendRequest = sendRequest;\n\nvar _request = __webpack_require__(/*! ./request */ \"./src/core/lib/request.js\");\n\nvar _request2 = _interopRequireDefault(_request);\n\nvar _result = __webpack_require__(/*! ../modules/result */ \"./src/core/modules/result.js\");\n\nvar _result2 = _interopRequireDefault(_result);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * @method addSpread\n * @description method to add the spread.\n */\n(function addSpread() {\n    if (Promise.prototype.spread) return;\n    Promise.prototype.spread = function (fn, errFunc) {\n        errFunc = errFunc || function (err) {};\n        return this.then(function (args) {\n            return fn.apply(fn, args);\n        }).catch(function (err) {\n            errFunc(err);\n        });\n    };\n})();\n\nfunction transform(type) {\n    return function () {\n        this._query[type] = this._query[type] || {};\n        switch (arguments.length) {\n            case 1:\n                if (Array.isArray(arguments[0]) || typeof arguments[0] === \"string\") {\n                    var query = this._query[type]['BASE'] || [];\n                    query = query.concat(arguments[0]);\n                    this._query[type]['BASE'] = query;\n                    return this;\n                } else {\n                    console.error(\"Kindly provide valid parameters\");\n                }\n                break;\n            case 2:\n                if (typeof arguments[0] === \"string\" && (Array.isArray(arguments[1]) || typeof arguments[1] === \"string\")) {\n                    var _query2 = this._query[type][arguments[0]] || [];\n                    _query2 = _query2.concat(arguments[1]);\n                    this._query[type][arguments[0]] = _query2;\n                    return this;\n                } else {\n                    console.error(\"Kindly provide valid parameters\");\n                }\n                break;\n            default:\n                console.error(\"Kindly provide valid parameters\");\n        }\n    };\n}\n\nfunction _type(val) {\n    var _typeof = void 0,\n        __typeof = typeof val === 'undefined' ? 'undefined' : _typeof2(val);\n    switch (__typeof) {\n        case 'object':\n            _typeof = __typeof;\n            if (Array.isArray(val)) {\n                __typeof = 'array';\n            }\n            break;\n        default:\n            _typeof = __typeof;\n    }\n    return __typeof;\n};\n\n// merge two objects\nfunction mergeDeep(target, source) {\n    var self = this;\n    var _merge_recursive = function _merge_recursive(target, source) {\n        for (var key in source) {\n            if (self._type(source[key]) == 'object' && self._type(target[key]) == self._type(source[key])) {\n                _merge_recursive(target[key], source[key]);\n            } else if (self._type(source[key]) == 'array' && self._type(target[key]) == self._type(source[key])) {\n                target[key] = target[key].concat(source[key]);\n            } else {\n                target[key] = source[key];\n            }\n        }\n    };\n    _merge_recursive(target, source);\n    return target;\n};\n\n// merge two objects\nfunction merge(target, source) {\n    if (target && source) {\n        for (var key in source) {\n            target[key] = source[key];\n        }\n    }\n    return target;\n};\n\n// return true if process is running in browser else false\nfunction isBrowser() {\n    return typeof window !== \"undefined\" && (typeof process === 'undefined' ? 'undefined' : _typeof2(process)) === \"object\" && process.title === \"browser\";\n};\n\n// return the query from the params\nfunction parseQueryFromParams(queryObject, single, toJSON) {\n    if (queryObject && queryObject.requestParams) {\n        var _query = merge({}, queryObject.requestParams.body ? queryObject.requestParams.body.query || {} : {});\n        if (_query.environment_uid) {\n            delete _query.environment_uid;\n            _query.environment = queryObject.environment;\n        }\n        _query.environment = queryObject.environment;\n        return {\n            content_type_uid: queryObject.content_type_uid,\n            locale: _query.locale || 'en-us',\n            query: _query,\n            entry_uid: queryObject.entry_uid,\n            asset_uid: queryObject.asset_uid,\n            single: single || \"false\",\n            toJSON: toJSON || \"false\",\n            api_key: queryObject.requestParams.headers ? queryObject.requestParams.headers.api_key : \"\"\n        };\n    }\n};\n\n// returrn the hash value of the query\nfunction getHash(query) {\n    try {\n        var hashValue = generateHash(JSON.stringify(query)),\n            keyArray = [];\n        keyArray.push(query.content_type_uid);\n        keyArray.push(query.locale);\n        if (query.entry_uid) keyArray.push(query.entry_uid);\n        if (query.asset_uid) keyArray.push(query.asset_uid);\n        keyArray.push(hashValue);\n        return keyArray.join('.');\n    } catch (e) {}\n};\n\n// return the hash value of the string\nfunction generateHash(str) {\n    var hash = 0,\n        i = void 0,\n        chr = void 0,\n        len = void 0;\n    if (str.length === 0) return hash;\n    for (i = 0, len = str.length; i < len; i++) {\n        chr = str.charCodeAt(i);\n        hash = (hash << 5) - hash + chr;\n        hash |= 0; // Convert to 32bit integer\n    }\n    return hash < -1 ? hash * -1 : hash;\n};\n\n// generate the Result object\nfunction resultWrapper(result) {\n    if (result && typeof result.entries !== 'undefined') {\n        if (result.entries && result.entries.length) {\n            for (var i = 0, _i = result.entries.length; i < _i; i++) {\n                result.entries[i] = (0, _result2.default)(result.entries[i]);\n            }\n        } else {\n            result.entries = [];\n        }\n    } else if (result && result.assets && typeof result.assets !== 'undefined') {\n        if (result.assets && result.assets.length) {\n            for (var j = 0, _j = result.assets.length; j < _j; j++) {\n                result.assets[j] = (0, _result2.default)(result.assets[j]);\n            }\n        } else {\n            result.assets = [];\n        }\n    } else if (result && typeof result.entry !== 'undefined') {\n        result.entry = (0, _result2.default)(result.entry);\n    } else if (result && typeof result.asset !== 'undefined') {\n        result.asset = (0, _result2.default)(result.asset);\n    } else if (result && typeof result.items !== 'undefined') {\n        result.items = (0, _result2.default)(result.items).toJSON();\n    }\n\n    return result;\n};\n\n// // spread the result object\n// export function spreadResult(result) {\n//     let _results = [];\n//     if (result && Object.keys(result).length) {\n//         if (typeof result.entries !== 'undefined') _results.push(result.entries);\n//         if (typeof result.assets !== 'undefined') _results.push(result.assets);\n//         if (typeof result.content_type !== 'undefined' || typeof result.schema !== 'undefined') _results.push(result.content_type || result.schema);\n//         if (typeof result.count !== 'undefined') _results.push(result.count);\n//         if (typeof result.entry !== 'undefined') _results = result.entry;\n//         if (typeof result.asset !== 'undefined') _results = result.asset;\n//         if (typeof result.items !== 'undefined') _results.push(result);\n//     }\n//     return _results;\n// };\n\n// spread the result object\nfunction spreadResult(result) {\n    var _results = [];\n    if (result && Object.keys(result).length) {\n        if (typeof result.entries !== 'undefined') {\n            _results.push(result.entries);\n            if (result.content_type) {\n                _results['schema'] = result.content_type;\n            }\n        }\n        if (typeof result.assets !== 'undefined') _results.push(result.assets);\n        if (typeof result.content_type !== 'undefined' || typeof result.schema !== 'undefined') _results.push(result.content_type || result.schema);\n        if (typeof result.count !== 'undefined') _results.push(result.count);\n        if (typeof result.entry !== 'undefined') {\n            _results = result.entry;\n            if (result.schema) {\n                _results['schema'] = result.schema;\n            }\n            if (result.content_type) {\n                _results['content_type'] = result.content_type;\n            }\n        }\n        if (typeof result.asset !== 'undefined') _results = result.asset;\n        if (typeof result.items !== 'undefined') _results.push(result);\n    }\n    return _results;\n};\n\nfunction sendRequest(queryObject, options) {\n\n    var env_uid = queryObject.environment_uid;\n    if (env_uid) {\n        queryObject._query.environment_uid = env_uid;\n    } else {\n        if (queryObject._query) {\n            queryObject._query.environment = queryObject.environment;\n        } else {\n            queryObject['_query'] = {};\n            queryObject._query['environment'] = queryObject.environment;\n        }\n    }\n\n    var self = queryObject;\n    var continueFlag = false;\n    var cachePolicy = typeof self.queryCachePolicy !== 'undefined' ? self.queryCachePolicy : self.cachePolicy;\n    var tojson = typeof self.tojson !== 'undefined' ? self.tojson : false;\n    var isSingle = self.entry_uid || self.singleEntry || self.asset_uid ? true : false;\n    var hashQuery = getHash(parseQueryFromParams(self, isSingle, tojson));\n\n    /**\n    for new api v3\n    */\n    if (queryObject && queryObject.requestParams && queryObject.requestParams.body && queryObject.requestParams.body.query) {\n        var cloneQueryObj = JSON.parse(JSON.stringify(queryObject.requestParams.body.query));\n        if ((typeof cloneQueryObj === 'undefined' ? 'undefined' : _typeof2(cloneQueryObj)) !== 'object') {\n            cloneQueryObj = JSON.parse(cloneQueryObj);\n        }\n        delete queryObject.requestParams.body.query;\n        queryObject.requestParams.body = merge(queryObject.requestParams.body, cloneQueryObj);\n    }\n\n    var getCacheCallback = function getCacheCallback() {\n        return function (err, entries) {\n            return new Promise(function (resolve, reject) {\n                try {\n                    if (err) throw err;\n                    if (!tojson) entries = resultWrapper(entries);\n                    resolve(spreadResult(entries));\n                } catch (e) {\n                    reject(e);\n                }\n            });\n        };\n    };\n\n    var callback = function callback(continueFlag, resolve, reject) {\n        if (continueFlag) {\n            (0, _request2.default)(queryObject.requestParams, options).then(function (data) {\n                try {\n                    self.entry_uid = self.asset_uid = self.tojson = self.queryCachePolicy = undefined;\n                    var entries = {};\n                    var syncstack = {};\n                    if (queryObject.singleEntry) {\n                        queryObject.singleEntry = false;\n                        if (data.schema) entries.schema = data.schema;\n                        if (data.content_type) {\n                            entries.content_type = data.content_type;\n                            delete entries.schema;\n                        }\n                        if (data.entries && data.entries.length) {\n                            entries.entry = data.entries[0];\n                        } else if (data.assets && data.assets.length) {\n                            entries.assets = data.assets[0];\n                        } else {\n                            if (cachePolicy === 2 && self.provider !== null) {\n                                self.provider.get(hashQuery, getCacheCallback());\n                            } else {\n                                return reject({ error_code: 141, error_message: 'The requested entry doesn\\'t exist.' });\n                            }\n                            return;\n                        }\n                    } else if (data.items) {\n                        syncstack = {\n                            items: data.items,\n                            pagination_token: data.pagination_token,\n                            sync_token: data.sync_token,\n                            total_count: data.total_count\n                        };\n                    } else {\n                        entries = data;\n                    }\n\n                    if (cachePolicy !== -1 && self.provider !== null) {\n                        self.provider.set(hashQuery, entries, function (err) {\n                            try {\n                                if (err) throw err;\n                                if (!tojson) entries = resultWrapper(entries);\n                                return resolve(spreadResult(entries));\n                            } catch (e) {\n                                return reject(e);\n                            }\n                        });\n                        return resolve(spreadResult(entries));\n                    }\n\n                    if (Object.keys(syncstack).length) {\n                        return resolve(syncstack);\n                    }\n\n                    if (!tojson) entries = resultWrapper(entries);\n                    return resolve(spreadResult(entries));\n                } catch (e) {\n                    return reject({\n                        message: e.message\n                    });\n                }\n            }.bind(self)).catch(function (error) {\n                if (cachePolicy === 2 && self.provider !== null) {\n                    self.provider.get(hashQuery, getCacheCallback());\n                } else {\n                    return reject(error);\n                }\n            });\n        }\n    };\n    switch (cachePolicy) {\n        case 1:\n            return new Promise(function (resolve, reject) {\n                if (self.provider !== null) {\n                    self.provider.get(hashQuery, function (err, _data) {\n                        try {\n                            if (err || !_data) {\n                                callback(true, resolve, reject);\n                            } else {\n                                if (!tojson) _data = resultWrapper(_data);\n                                return resolve(spreadResult(_data));\n                            }\n                        } catch (e) {\n                            return reject(e);\n                        }\n                    });\n                } else {\n                    callback(true, resolve, reject);\n                }\n            });\n            break;\n        case 2:\n        case 0:\n        case undefined:\n        case -1:\n            return new Promise(function (resolve, reject) {\n                callback(true, resolve, reject);\n            });\n    };\n\n    if (cachePolicy === 3) {\n\n        var promise = new Promise(function (resolve, reject) {\n            if (self.provider !== null) {\n                self.provider.get(hashQuery, function (err, _data) {\n                    try {\n                        if (err || !_data) {\n                            reject(err);\n                            //reject(Error(\"It broke\"));\n                        } else {\n                            if (!tojson) _data = resultWrapper(_data);\n                            resolve(spreadResult(_data));\n                        }\n                    } catch (e) {\n                        reject(e);\n                    }\n                });\n            }\n        });\n\n        return promise.then(function () {\n            return new Promise(function (resolve, reject) {\n                callback(true, resolve, reject);\n            });\n        }).catch(function (error) {\n            return new Promise(function (resolve, reject) {\n                callback(true, resolve, reject);\n            });\n            console.error(error);\n        });\n    }\n};\n\n//# sourceURL=webpack://Contentstack/./src/core/lib/utils.js?");

/***/ }),

/***/ "./src/core/modules/assets.js":
/*!************************************!*\
  !*** ./src/core/modules/assets.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(/*! ../lib/utils */ \"./src/core/lib/utils.js\");\n\nvar Utils = _interopRequireWildcard(_utils);\n\nvar _stack = __webpack_require__(/*! ../stack */ \"./src/core/stack.js\");\n\nvar _stack2 = _interopRequireDefault(_stack);\n\nvar _query = __webpack_require__(/*! ./query */ \"./src/core/modules/query.js\");\n\nvar _query2 = _interopRequireDefault(_query);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @class \n  Assets  \n* @summary Creates an instance of `Assets`.\n* @description Retrieves all assets of a stack by default. To retrieve a single asset, specify its UID.\n* @param {String} uid - uid of asset you want to retrieve\n* @example \n* let data = Stack.Assets('bltsomething123').toJSON().fetch()\n*      data\n*      .then(function(result) {\n*           // ‘result’ is a single asset object of specified uid       \n*      }, function(error) {\n*           // error function\n*      })\n* @example \n* // Retrieves all assets*\n* let data = Stack.Assets().Query().toJSON().find()\n*      data\n*      .then(function(result) {\n*          // All the asset with limit of 100\n*          // Use skip and limit functions to paginate\n*          // ‘result’ will display all assets present in stack       \n*      }, function(error) {\n*           // error function\n*      })\n* @returns {Assets}\n* @instance\n*/\n\nvar Assets = function () {\n    function Assets() {\n        _classCallCheck(this, Assets);\n\n        this._query = {};\n        this.only = Utils.transform('only');\n        return this;\n    }\n\n    /**\n      * Converts your response into plain JavasScript object\n      * @memberOf Assets\n      * @example var Query = Stack.ContentType('blog').Query()\n       Query   \n            .toJSON()\n            .find()\n            .then(function (result) {\n                // 'result' is an object which content the data in json object form\n             },function (error) {\n                // error function\n        })\n      * @returns {Assets}\n      * @instance\n      */\n\n    _createClass(Assets, [{\n        key: 'toJSON',\n        value: function toJSON() {\n            this.tojson = true;\n            return this;\n        }\n\n        /**\n           * Includes query parameters in your queries.\n           * @memberOf Assets\n           * @example var data = Stack.Assets(assetUid).addParam('include_dimension', 'true').toJSON().fetch()\n             *      data.then(function (result) {\n             *          // 'result' is an object which content the data including count in json object form\n             *       },function (error) {\n             *          // error function\n             *      })\n             * @returns {Assets}\n             * @instance\n           */\n\n    }, {\n        key: 'addParam',\n        value: function addParam(key, value) {\n            if (key && typeof key === 'string' && value && typeof value === 'string') {\n                this._query[key] = value;\n                return this;\n            } else {\n                console.error(\"Kindly provide a valid parameters.\");\n            }\n        }\n\n        /**\n         * @method includeFallback\n         * @memberOf Entry\n         * @description Include the fallback locale publish content, if specified locale content is not publish.\n         * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeFallback().fetch()\n         * @returns {Asset}\n         * @instance\n         */\n\n    }, {\n        key: 'includeFallback',\n        value: function includeFallback() {\n            this._query['include_fallback'] = true;\n            return this;\n        }\n\n        /**\n           * Fetches a particular asset based on the provided asset UID.\n           * @memberOf Assets\n           * @example\n           * Stack.Assets('assets_uid').toJSON().fetch()\n           * @example\n           * Stack.Assets('assets_uid').toJSON().fetch({\n           *         \n           *      })\n           * @returns {promise}\n           * @instance\n           */\n\n    }, {\n        key: 'fetch',\n        value: function fetch(fetchOptions) {\n            if (this.asset_uid) {\n                this.requestParams = {\n                    method: 'POST',\n                    headers: this.headers,\n                    url: this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.assets + this.asset_uid,\n                    body: {\n                        _method: 'GET',\n                        query: this._query\n                    }\n                };\n                var options = Object.assign({}, this.fetchOptions, fetchOptions);\n                return Utils.sendRequest(this, options);\n            } else {\n                console.error(\"Kindly provide an asset uid. e.g. .Assets('bltsomething123')\");\n            }\n        }\n    }]);\n\n    return Assets;\n}();\n\nexports.default = Assets;\n\n//# sourceURL=webpack://Contentstack/./src/core/modules/assets.js?");

/***/ }),

/***/ "./src/core/modules/entry.js":
/*!***********************************!*\
  !*** ./src/core/modules/entry.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(/*! ../lib/utils */ \"./src/core/lib/utils.js\");\n\nvar Utils = _interopRequireWildcard(_utils);\n\nvar _stack = __webpack_require__(/*! ../stack */ \"./src/core/stack.js\");\n\nvar _stack2 = _interopRequireDefault(_stack);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @class \n  Entry \n* @summary Creates an instance of `Entry`.   \n* @description An initializer is responsible for creating Entry object.\n* @param {String} uid - uid of the entry\n* @example\n* let Entry = Stack.ContentType('example').Entry('entry_uid');\n* @returns {Entry}\n* @instance\n*/\n\nvar Entry = function () {\n    function Entry() {\n        _classCallCheck(this, Entry);\n\n        this._query = {};\n        /**\n         * @method only\n         * @memberOf Entry\n         * @description Displays values of only the specified fields of entries or assets in the response\n         * @param {String} [key=BASE] -  Assets: </br>\n         *                                <p>Retrieves specified field of asset</p>\n         * @param {String}            -  Entries:</br>\n         *                                       <p>- retrieves default fields of the schema.</p>\n         *                                       <p>- referenced_content-type-uid : retrieves fields of the referred content type.</p>\n         * @param {Array} values - array of fields that you want to display in the response\n         * @example\n         * <caption> The only function with field_uid will include the data of only the specified fields for each entry and exclude the data of all other fields. </caption>\n         * Stack.ContentType('contentTypeUid').Query().only('title').toJSON().find()\n         * \n         * <caption> The only function with an array of field_uids will include multiple fields for each entry and exclude the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().only(['title','description']).toJSON().find()\n         * \n         * <caption> In only, we have the only with a reference parameter, where you need to enter the UID of the reference field in place of \"reference_field_uid\", and the second parameter to include the data of only the specified field_uid for each entry and exclude the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().includeReference('reference_field_uid').only('reference_field_uid','title').toJSON().find()\n         * \n         * <caption> In only, we have the only with a reference parameter with an array, where you need to enter the UID of the reference field in place of \"reference_field_uid\", and the second parameter with an array of fields to include the data of only the specified array of field_uids for each entry and exclude the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().includeReference('reference_field_uid').only('reference_field_uid', ['title', 'description']).toJSON().find()\n         * \n         * @returns {Entry}\n         * @instance\n         */\n        this.only = Utils.transform('only');\n        /**\n         * @method except\n         * @memberOf Entry\n         * @description Displays all data of an entries or assets excluding the data of the specified fields.\n         * @param {String} [key=BASE] - BASE (default value) - retrieves default fields of the schema.\n                                                             - referenced_content-type-uid - retrieves fields of the referred content type.\n         * @param {Array} values - array of fields that you want to skip in the response\n         * @example\n         * <caption> The except function with field_uid will exclude the data of only the specified fields for each entry and includes the data of all other fields. </caption>\n         * Stack.ContentType('contentTypeUid').Query().except('title').toJSON().find()\n         * @example\n         * <caption> The except function with an array of field_uids will except multiple fields for each entry and include the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().except(['title','description']).toJSON().find()\n         * @example\n         * <caption> In except, we have the only with a reference parameter, where you need to enter the UID of the reference field in place of \"reference_field_uid\", and the second parameter to except the data of only the specified field_uid for each entry and include the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().includeReference('reference_field_uid').except('reference_field_uid','title').toJSON().find()\n         * @example\n         * <caption> In except, we have the only with a reference parameter with an array, where you need to enter the UID of the reference field in place of \"reference_field_uid\", and the second parameter with an array of fields to except the data of only the specified array of field_uids for each entry and include the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().includeReference('reference_field_uid').except('reference_field_uid', ['title', 'description']).toJSON().find()\n         * @returns {Entry}\n         * @instance \n         */\n        this.except = Utils.transform('except');\n        return this;\n    }\n\n    _createClass(Entry, [{\n        key: \"setCacheProvider\",\n        value: function setCacheProvider(provider) {\n            if (provider && (typeof provider === \"undefined\" ? \"undefined\" : _typeof(provider)) === 'object') {\n                this.provider = provider;\n            }\n            return this;\n        }\n    }, {\n        key: \"setCachePolicy\",\n        value: function setCachePolicy(policy) {\n            if (typeof policy === 'number' && policy >= -1 && policy < 4) {\n                if (!this._query) {\n                    this.cachePolicy = policy;\n                } else {\n                    this.queryCachePolicy = policy;\n                }\n            } else {\n                console.error(\"Kindly provide the valid policy\");\n            }\n            return this;\n        }\n\n        /**\n            * @method includeReference\n            * @memberOf Entry\n            * @description Fetches the entire content of referenced entry(ies). <a href='https://www.contentstack.com/docs/developers/apis/content-delivery-api/#include-reference'>Read More</a>\n            * @example\n            * <caption> .includeReference with reference_field_uids as array </caption>\n            * var Query = Stack.ContentType(contentTypes.source).Query();\n                   Query\n                       .includeReference(['reference_field_uid', 'other_reference_field_uid'])\n                       .toJSON()\n                       .find()\n                       .then(function success(entries) {\n                           //'entries' is  an object used to retrieve data including reference entries.\n                       })\n            * @example\n            * <caption> .includeReference with reference_field_uids and its children reference </caption>\n            * var Query = Stack.ContentType(contentTypes.source).Query();\n                   Query\n                       .includeReference(['reference_field_uid', 'reference_field_uid.child_reference_field_uid'])\n                       .toJSON()\n                       .find()\n                       .then(function success(entries) {\n                           //'entries' is  an object used to retrieve data including reference entries.\n                       })\n            * @example\n            * <caption> .includeReference with reference_field_uids </caption>\n            * var Query = Stack.ContentType(contentTypes.source).Query(); \n            Query\n               .includeReference('reference_field_uid')\n               .toJSON()\n               .find()\n               .then(function success(entries) {\n                   //'entries' is  an object used to retrieve data including particular reference using reference_uid.\n               })\n            * @returns {Entry}\n            * @instance\n            */\n\n    }, {\n        key: \"includeReference\",\n        value: function includeReference() {\n            for (var _len = arguments.length, val = Array(_len), _key = 0; _key < _len; _key++) {\n                val[_key] = arguments[_key];\n            }\n\n            if (Array.isArray(val) || typeof val === \"string\") {\n                if (arguments.length) {\n                    for (var i = 0; i < arguments.length; i++) {\n                        this._query['include'] = this._query['include'] || [];\n                        this._query['include'] = this._query['include'].concat(arguments[i]);\n                    }\n                }\n                return this;\n            } else {\n                console.error(\"Argument should be a String or an Array.\");\n            }\n        }\n\n        /**\n        * Sets the language code of which you want to retrieve data.\n        * @param {String} language_code - language code. e.g. 'en-us', 'ja-jp', etc.\n        * @memberOf Entry\n        * @example \n        * let data = Stack.ContentType(contentTypeUid).Entry(entryUid).language('ja-jp').fetch()\n        * data\n        *      .then(function(result) {\n        *           // 'result' is  an object used to retrieve data of ja-jp language.\n        *      }, function(error) {\n        *           // error function\n        *      })\n        *          \n        * @returns {Entry}\n        * @instance\n        */\n\n    }, {\n        key: \"language\",\n        value: function language(language_code) {\n            if (language_code && typeof language_code === 'string') {\n                this._query['locale'] = language_code;\n                return this;\n            } else {\n                console.error(\"Argument should be a String.\");\n            }\n        }\n\n        /**\n        * @method addQuery\n        * @memberOf Entry\n        * @description Adds query to Entry object\n        * @param {String} key - key of the query\n        * @param {String} value - value of the query\n        * @example Stack.ContentType(contentTypeUid).Entry(entry_uid).addQuery('include_schema',true)\n        * @returns {Entry}\n        * @instance\n        */\n\n    }, {\n        key: \"addQuery\",\n        value: function addQuery(key, value) {\n            if (key && value && typeof key === 'string') {\n                this._query[key] = value;\n                return this;\n            } else {\n                console.error(\"First argument should be a String.\");\n            }\n        }\n\n        /**\n         * @method includeSchema\n         * @memberOf Entry\n         * @deprecated since verion 3.3.0\n         * @description  Include schema of the current content type along with entry/entries details.\n         * @example Stack.ContentType(\"contentType_uid\").Entry(\"entry_uid\").includeSchema().fetch()\n         * @returns {Entry}\n         * @instance\n         */\n\n    }, {\n        key: \"includeSchema\",\n        value: function includeSchema() {\n            this._query['include_schema'] = true;\n            return this;\n        }\n\n        /**\n         * @method includeReferenceContentTypeUid\n         * @memberOf Entry\n         * @description  This method also includes the content type UIDs of the referenced entries returned in the response.\n         * @example Stack.ContentType(\"contentType_uid\").Entry(\"entry_uid\").includeReferenceContentTypeUID().fetch()\n         * @example \n         * Query = Stack.ContentType(\"contentType_uid\").Entry(\"entry_uid\").includeReferenceContentTypeUID().fetch()\n         * Query\n         *      .toJSON()\n         *      .then(function (result) {\n         *          let value = result.get(field_uid)\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Entry}\n         * @instance\n         */\n\n    }, {\n        key: \"includeReferenceContentTypeUID\",\n        value: function includeReferenceContentTypeUID() {\n            this._query['include_reference_content_type_uid'] = true;\n            return this;\n        }\n\n        /**\n         * @method includeFallback\n         * @memberOf Entry\n         * @description Include the fallback locale publish content, if specified locale content is not publish.\n         * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeFallback().fetch()\n         * @returns {Entry}\n         * @instance\n         */\n\n    }, {\n        key: \"includeFallback\",\n        value: function includeFallback() {\n            this._query['include_fallback'] = true;\n            return this;\n        }\n\n        /**\n         * @method includeContentType\n         * @memberOf Entry\n         * @description Include the details of the content type along with the entry/entries details.\n         * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeContentType().fetch()\n         * @returns {Entry}\n         * @instance\n         */\n\n    }, {\n        key: \"includeContentType\",\n        value: function includeContentType() {\n            this._query['include_content_type'] = true;\n            return this;\n        }\n\n        /**\n          * @method includeOwner\n          * @memberOf Entry \n          * @description Includes the owner details of the entry/entries\n          * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeOwner().fetch()\n          * @returns {Entry}\n          * @instance\n          */\n\n    }, {\n        key: \"includeOwner\",\n        value: function includeOwner() {\n            this._query['include_owner'] = true;\n            return this;\n        }\n\n        /**\n         * @method toJSON\n         * @memberOf Entry \n         * @description Converts your response into plain JavasScript object.Supports both entry and asset queries.\n         * @example\n         * Query = Stack.ContentType(contentTypeUid).Entry(entryUid).fetch()\n         * Query\n         *      .toJSON()\n         *      .then(function (result) {\n         *          let value = result.get(field_uid)\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Entry}\n         * @instance\n         */\n\n    }, {\n        key: \"toJSON\",\n        value: function toJSON() {\n            this.tojson = true;\n            return this;\n        }\n\n        /**\n         * @method addParam\n         * @memberOf Entry \n         * @description Includes query parameters in your queries.\n         * @example var data = Stack.ContentType(contentTypeUid).Entry(entryUid).addParam('include_count', 'true').fetch()\n         *      data.then(function (result) {\n         *          // 'result' is an object which content the data including count in json object form\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Entry}\n         * @instance\n         */\n\n    }, {\n        key: \"addParam\",\n        value: function addParam(key, value) {\n            if (key && value && typeof key === 'string' && typeof value === 'string') {\n                this._query[key] = value;\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        }\n\n        /**\n        * @method fetch\n        * @memberOf Entry \n        * @description Fetches a particular entry based on the provided entry UID.\n        * @example\n        * Stack.ContentType(contentTypeUid).Entry(entryUid).toJSON().fetch()\n        * \n        * @example\n        * Stack.ContentType(contentTypeUid).Entry(entryUid).toJSON().fetch({\n        *         \n        *      })\n        * @returns {promise}\n        * @instance\n        */\n\n    }, {\n        key: \"fetch\",\n        value: function fetch(fetchOptions) {\n            if (this.entry_uid) {\n                this.requestParams = {\n                    method: 'POST',\n                    headers: this.headers,\n                    url: this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.content_types + this.content_type_uid + this.config.urls.entries + this.entry_uid,\n                    body: {\n                        _method: 'GET',\n                        query: this._query\n                    }\n                };\n                var options = Object.assign({}, this.fetchOptions, fetchOptions);\n                return Utils.sendRequest(this, options);\n            } else {\n                console.error(\"Kindly provide an entry uid. e.g. .Entry('bltsomething123')\");\n            }\n        }\n    }]);\n\n    return Entry;\n}();\n\nexports.default = Entry;\n\n//# sourceURL=webpack://Contentstack/./src/core/modules/entry.js?");

/***/ }),

/***/ "./src/core/modules/query.js":
/*!***********************************!*\
  !*** ./src/core/modules/query.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _request = __webpack_require__(/*! ../lib/request */ \"./src/core/lib/request.js\");\n\nvar _request2 = _interopRequireDefault(_request);\n\nvar _utils = __webpack_require__(/*! ../lib/utils.js */ \"./src/core/lib/utils.js\");\n\nvar Utils = _interopRequireWildcard(_utils);\n\nvar _entry = __webpack_require__(/*! ./entry */ \"./src/core/modules/entry.js\");\n\nvar _entry2 = _interopRequireDefault(_entry);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _extend = {\n    compare: function compare(type) {\n        return function (key, value) {\n            if (key && value && typeof key === 'string' && typeof value !== 'undefined') {\n                this._query['query'][key] = this._query['query']['file_size'] || {};\n                this._query['query'][key][type] = value;\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        };\n    },\n    contained: function contained(bool) {\n        var type = bool ? '$in' : '$nin';\n        return function (key, value) {\n            if (key && value && typeof key === 'string' && Array.isArray(value)) {\n                this._query['query'][key] = this._query['query'][key] || {};\n                this._query['query'][key][type] = this._query['query'][key][type] || [];\n                this._query['query'][key][type] = this._query['query'][key][type].concat(value);\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        };\n    },\n    exists: function exists(bool) {\n        return function (key) {\n            if (key && typeof key === 'string') {\n                this._query['query'][key] = this._query['query'][key] || {};\n                this._query['query'][key]['$exists'] = bool;\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        };\n    },\n    logical: function logical(type) {\n        return function () {\n            var _query = [];\n            for (var i = 0, _i = arguments.length; i < _i; i++) {\n                if (arguments[i] instanceof Query && arguments[i]._query.query) {\n                    _query.push(arguments[i]._query.query);\n                } else if (_typeof(arguments[i]) === \"object\") {\n                    _query.push(arguments[i]);\n                }\n            }\n            if (this._query['query'][type]) {\n                this._query['query'][type] = this._query['query'][type].concat(_query);\n            } else {\n                this._query['query'][type] = _query;\n            }\n            return this;\n        };\n    },\n    sort: function sort(type) {\n        return function (key) {\n            if (key && typeof key === 'string') {\n                this._query[type] = key;\n                return this;\n            } else {\n                console.error(\"Argument should be a string.\");\n            }\n        };\n    },\n    pagination: function pagination(type) {\n        return function (value) {\n            if (typeof value === 'number') {\n                this._query[type] = value;\n                return this;\n            } else {\n                console.error(\"Argument should be a number.\");\n            }\n        };\n    }\n};\n\n/**\n * @class \n   Query  \n * @description\n * An initializer is responsible for creating Query object.Provides support for all search queries\n * @example\n * <caption>Query instance creation.</caption>\n * let Query = Contentstack.Stack().ContentType('example').Query();\n * let assetQuery =  Contentstack.Stack().Assets().Query();\n * @returns {Query}\n */\n\nvar Query = function (_Entry) {\n    _inherits(Query, _Entry);\n\n    function Query() {\n        _classCallCheck(this, Query);\n\n        var _this = _possibleConstructorReturn(this, (Query.__proto__ || Object.getPrototypeOf(Query)).call(this));\n\n        _this._query = _this._query || {};\n        _this._query['query'] = _this._query['query'] || {};\n        /**\n        * @method lessThan\n        * @memberOf Query\n        * @description Retrieves entries in which the value of a field is lesser than the provided value\n        * @param {String} key - uid of the field\n        * @param {*} value - Value used to match or compare\n        * @example let blogQuery = Stack().ContentType('example').Query();\n        *          let data = blogQuery.lessThan('created_at','2015-06-22').find()\n        *          data.then(function (result) {\n        *          // result content the data who's 'created_at date' is less than '2015-06-22'\n        *       },function (error) {\n        *          // error function\n        *      })\n        * @returns {Query}\n        * @instance\n        */\n        _this.lessThan = _extend.compare('$lt');\n\n        /**\n        * @method lessThanOrEqualTo\n        * @memberOf Query\n        * @description Retrieves entries in which the value of a field is lesser than or equal to the provided value.\n        * @param {String} key - uid of the field\n        * @param {*} value - Value used to match or compare\n        * @example let blogQuery = Stack().ContentType('example').Query();\n        *          let data = blogQuery.lessThanOrEqualTo('created_at','2015-06-22').find()\n        *          data.then(function (result) {\n        *          // result contain the data of entries where the 'created_at' date will be less than or equalto '2015-06-22'.\n        *       },function (error) {\n        *          // error function\n        *      })\n        * @returns {Query}\n        * @instance\n        */\n        _this.lessThanOrEqualTo = _extend.compare('$lte');\n        /**\n        * @method greaterThan\n        * @memberOf Query\n        * @description Retrieves entries in which the value for a field is greater than the provided value.\n        * @param {String} key - uid of the field\n        * @param {*} value -  value used to match or compare\n        * @example \n        *          let blogQuery = Stack().ContentType('example').Query();\n        *          let data = blogQuery.greaterThan('created_at','2015-03-12').find()\n        *                     data.then(function(result) {\n        *                       // result contains the data of entries where the 'created_at' date will be greaterthan '2015-06-22'\n        *                     },function (error) {\n        *                       // error function\n        *                     })\n        * @returns {Query}\n        * @instance\n        */\n        _this.greaterThan = _extend.compare('$gt');\n\n        /**\n         * @method greaterThanOrEqualTo\n         * @memberOf Query\n         * @description Retrieves entries in which the value for a field is greater than or equal to the provided value.\n         * @param {String} key - uid of the field \n         * @param {*} value - Value used to match or compare\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.greaterThanOrEqualTo('created_at','2015-03-12').find()\n         *          data.then(function(result) {\n         *          // result contains the data of entries where the 'created_at' date will be greaterThan or equalto '2015-06-22'\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n        _this.greaterThanOrEqualTo = _extend.compare('$gte');\n\n        /**\n         * @method notEqualTo\n         * @memberOf Query\n         * @description Retrieves entries in which the value for a field does not match the provided value.\n         * @param {String} key - uid of the field \n         * @param {*} value - Value used to match or compare\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.notEqualTo('title','Demo').find()\n         *          data.then(function(result) {\n         *            // ‘result’ contains the list of entries where value of the ‘title’ field will not be 'Demo'.\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n        _this.notEqualTo = _extend.compare('$ne');\n\n        /**\n         * @method containedIn\n         * @memberOf Query\n         * @description Retrieve entries in which the value of a field matches with any of the provided array of values\n         * @param {String} key - uid of the field\n         * @param {*} value - Array of values that are to be used to match or compare\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.containedIn('title', ['Demo', 'Welcome']).find()\n         *          data.then(function(result) {\n         *          // ‘result’ contains the list of entries where value of the ‘title’ field will contain either 'Demo' or ‘Welcome’.\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n        _this.containedIn = _extend.contained(true);\n\n        /**\n          * @method notContainedIn\n          * @memberOf Query\n          * @description Retrieve entries in which the value of a field does not match with any of the provided array of values.\n          * @param {String} key - uid of the field\n          * @param {Array} value - Array of values that are to be used to match or compare\n          * @example let blogQuery = Stack().ContentType('example').Query();\n          *          let data = blogQuery.notContainedIn('title', ['Demo', 'Welcome']).find()\n          *          data.then(function(result) {\n          *          // 'result' contains the list of entries where value of the title field should not be either \"Demo\" or ‘Welcome’\n          *       },function (error) {\n          *          // error function\n          *      })\n          * @returns {Query}\n          * @instance\n          */\n        _this.notContainedIn = _extend.contained(false);\n\n        /**\n        * @method exists \n        * @memberOf Query\n        * @description Retrieve entries if value of the field, mentioned in the condition, exists.\n        * @param {String} key - uid of the field\n        * @example blogQuery.exists('featured')\n        * @example let blogQuery = Stack().ContentType('example').Query();\n        *          let data = blogQuery.exists('featured').find()\n        *          data.then(function(result) {\n        *          // ‘result’ contains the list of entries in which \"featured\" exists.\n        *       },function (error) {\n        *          // error function\n        *      })\n        * @returns {Query}\n        * @instance\n        */\n        _this.exists = _extend.exists(true);\n\n        /**\n        * @method notExists\n        * @memberOf Query\n        * @description Retrieve entries if value of the field, mentioned in the condition, does not exists.\n        * @param {String} key - uid of the field\n        * @example blogQuery.notExists('featured')\n        * @example let blogQuery = Stack().ContentType('example').Query();\n        *          let data = blogQuery.notExists('featured').find()\n        *          data.then(function(result) {\n        *        // result is the list of non-existing’featured’\" data.\n        *       },function (error) {\n        *          // error function\n        *      })\n        * @returns {Query}\n        * @instance\n        */\n        _this.notExists = _extend.exists(false);\n\n        /**\n        * @method ascending\n        * @memberOf Query\n        * @description Sort fetched entries in the ascending order with respect to a specific field.\n        * @param {String} key - field uid based on which the ordering will be done\n        * @example let blogQuery = Stack().ContentType('example').Query();\n        *          let data = blogQuery.ascending('created_at').find()\n        *          data.then(function(result) {\n        *           // ‘result’ contains the list of entries which is sorted in ascending order on the basis of ‘created_at’. \n        *       },function (error) {\n        *          // error function\n        *      })\n        * @returns {Query}\n        * @instance\n        */\n        _this.ascending = _extend.sort('asc');\n\n        /**\n         * @method descending\n         * @memberOf Query\n         * @description Sort fetched entries in the descending order with respect to a specific field\n         * @param {String} key - field uid based on which the ordering will be done.\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.descending('created_at').find()\n         *          data.then(function(result) {\n         *           // ‘result’ contains the list of entries which is sorted in descending order on the basis of ‘created_at’. \n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n        _this.descending = _extend.sort('desc');\n\n        /**\n        * @method beforeUid\n        * @memberOf Query\n        * @description Sort fetched entries in the descending order with respect to a specific field\n        * @param {String} uid - field uid based on which the ordering will be done.\n        * @example blogQuery.beforeUid('blt1234567890abcdef')\n        * @returns {Query}\n        * @instance\n        */\n        _this.beforeUid = _extend.sort('before_uid');\n\n        /**\n         * @method afterUid\n         * @memberOf Query\n         * @description This method provides only the entries after the specified entry id.\n         * @param {String} uid - uid of the entry\n         * @example blogQuery.afterUid('blt1234567890abcdef')\n         * @returns {Query}\n         * @instance\n         */\n        _this.afterUid = _extend.sort('after_uid');\n\n        /**\n        * @method skip\n        * @memberOf Query\n        * @description Skips at specific number of entries.\n        * @param {Number} skip - number of entries to be skipped\n        * @example blogQuery.skip(5)\n        * @example let blogQuery = Stack().ContentType('example').Query();\n        *          let data = blogQuery.skip(5).find()\n        *          data.then(function(result) {\n        *          // result contains the list of data which is sorted in descending order on 'created_at' bases. \n        *       },function (error) {\n        *          // error function\n        *      })\n        * @returns {Query}\n        * @instance\n        */\n        _this.skip = _extend.pagination('skip');\n\n        /**\n        * @method limit\n        * @memberOf Query\n        * @description Returns a specific number of entries based on the set limit\n        * @param {Number} limit - maximum number of entries to be returned\n        * @example let blogQuery = Stack().ContentType('example').Query();\n        *          let data = blogQuery.limit(10).find()\n        *          data.then(function(result) {\n        *          // result contains the limited number of entries\n        *       },function (error) {\n        *          // error function\n        *      })\n        * @returns {Query}\n        * @instance\n        */\n        _this.limit = _extend.pagination('limit');\n\n        /**\n        * @method or\n        * @memberOf Query\n        * @description Retrieves entries that satisfy at least one of the given conditions\n        * @param {object} queries - array of Query objects or raw queries\n        * @example\n        * <caption> .or with Query instances</caption>\n        * let Query1 = Stack.ContentType('blog').Query().where('title', 'Demo').find()\n        * let Query2 = Stack.ContentType('blog').Query().lessThan('comments', 10).find()\n        * blogQuery.or(Query1, Query2)\n        * @example\n        * <caption> .or with raw queries</caption>\n        * let Query1 = Stack.ContentType('blog').Query().where('title', 'Demo').getQuery()\n        * let Query2 = Stack.ContentType('blog').Query().lessThan('comments', 10).getQuery()\n        * blogQuery.or(Query1, Query2)\n        * @returns {Query}\n        * @instance\n        */\n        _this.or = _extend.logical('$or');\n\n        /**\n         * @method and\n         * @memberOf Query\n         * @description Retrieve entries that satisfy all the provided conditions.\n         * @param {object} queries - array of query objects or raw queries.\n         * @example\n         * <caption> .and with Query instances</caption>\n         * let Query1 = Stack.ContentType('blog').Query().where('title', 'Demo')\n         * let Query2 = Stack.ContentType('blog').Query().lessThan('comments', 10)\n         * blogQuery.and(Query1, Query2)\n         * @example\n         * <caption> .and with raw queries</caption>\n         * let Query1 = Stack.ContentType('blog').Query().where('title', 'Demo').getQuery()\n         * let Query2 = Stack.ContentType('blog').Query().lessThan('comments', 10).getQuery()\n         * blogQuery.and(Query1, Query2)\n         * @returns {Query}\n         * @instance\n         */\n        _this.and = _extend.logical('$and');\n        return _this;\n    }\n\n    _createClass(Query, [{\n        key: 'equalTo',\n        value: function equalTo(key, value) {\n            if (key && typeof key === 'string') {\n                this._query['query'][key] = value;\n\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        }\n\n        /**\n         * @memberOf Query\n         * @description Retrieve entries in which a specific field satisfies the value provided\n         * @param {String} key - uid of the field\n         * @param {*} value - value used to match or compare\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.where('title','Demo').find()\n         *          data.then(function(result) {\n         *            // ‘result’ contains the list of entries where value of ‘title’ is equal to ‘Demo’. \n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'where',\n        value: function where(key, value) {\n            if (key && typeof key === 'string') {\n                this._query['query'][key] = value;\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        }\n\n        /**\n         * @method count\n         * @memberOf Query\n         * @description Returns the total number of entries\n         * @example blogQuery.count()\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.count().find()\n         *          data.then(function(result) {\n         *           // ‘result’ contains the total count. \n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'count',\n        value: function count() {\n            var host = this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version,\n                url = this.type && this.type === 'asset' ? host + this.config.urls.assets : host + this.config.urls.content_types + this.content_type_uid + this.config.urls.entries;\n            this._query['count'] = true;\n            this.requestParams = {\n                method: 'POST',\n                headers: this.headers,\n                url: url,\n                body: {\n                    _method: 'GET',\n                    query: this._query\n                }\n            };\n            return this;\n        }\n\n        /**\n         * @method query\n         * @memberOf Query\n         * @description Retrieve entries based on raw queries\n         * @param {object} query - RAW (JSON) queries \n         * @returns {Query}\n         * @instance\n         * @example \n         * let blogQuery = Stack().ContentType('example').Query();\n         * let data = blogQuery.query({\"brand\": {\"$nin_query\": {\"title\": \"Apple Inc.\"}}}).find()\n         * data.then(function(result) {\n         *    // ‘result’ contains the total count. \n         * },function (error) {\n         *    // error function\n         * })\n         */\n\n    }, {\n        key: 'query',\n        value: function query(_query2) {\n            if ((typeof _query2 === 'undefined' ? 'undefined' : _typeof(_query2)) === \"object\") {\n                this._query['query'] = Utils.mergeDeep(this._query['query'], _query2);\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters\");\n            }\n        }\n\n        /**\n         * @method referenceIn\n         * @memberOf Query\n         * @description Retrieve entries that satisfy the query conditions made on referenced fields.\n         * @param {Query} query - RAW (JSON) queries \n         * @returns {Query}\n         * @instance\n         * @example \n         * <caption> referenceIn with Query instances</caption>\n         * let blogQuery = Stack().ContentType('example').Query();\n         * let Query = Stack.ContentType('blog').Query().where('title', 'Demo')\n         * let data = blogQuery.referenceIn(\"brand\", Query).find()\n         * data.then(function(result) {\n         *    // ‘result’ contains the total count. \n         * },function (error) {\n         *    // error function\n         * })\n         * \n         * @example \n         * <caption> referenceIn with raw queries</caption>\n         * let blogQuery = Stack().ContentType('example').Query();\n         * let data = blogQuery.referenceIn(\"brand\", {'title': 'Demo'}).find()\n         * data.then(function(result) {\n         *    // ‘result’ contains the total count. \n         * },function (error) {\n         *    // error function\n         * })\n         */\n\n    }, {\n        key: 'referenceIn',\n        value: function referenceIn(key, query) {\n            var _query = {};\n            if (query instanceof Query && query._query.query) {\n                _query[\"$in_query\"] = query._query.query;\n            } else if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === \"object\") {\n                _query[\"$in_query\"] = query;\n            }\n            if (this._query['query'][key]) {\n                this._query['query'][key] = this._query['query'][key].concat(_query);\n            } else {\n                this._query['query'][key] = _query;\n            }\n            return this;\n        }\n\n        /**\n         * @method referenceNotIn\n         * @memberOf Query\n         * @description Retrieve entries that does not satisfy the query conditions made on referenced fields.\n         * @param {Query} query - RAW (JSON) queries \n         * @returns {Query}\n         * @instance\n         * @example \n         * <caption> referenceNotIn with Query instances</caption>\n         * let blogQuery = Stack().ContentType('example').Query();\n         * let data = blogQuery.referenceNotIn(\"brand\", {'title': 'Demo'}).find()\n         * data.then(function(result) {\n         *    // ‘result’ contains the total count. \n         * },function (error) {\n         *    // error function\n         * })\n         * \n         * @example \n         * <caption> referenceNotIn with raw queries</caption>\n         * let blogQuery = Stack().ContentType('example').Query();\n         * let Query = Stack.ContentType('blog').Query().where('title', 'Demo')\n         * let data = blogQuery.referenceNotIn(\"brand\", Query).find()\n         * data.then(function(result) {\n         *    // ‘result’ contains the total count. \n         * },function (error) {\n         *    // error function\n         * })\n         */\n\n    }, {\n        key: 'referenceNotIn',\n        value: function referenceNotIn(key, query) {\n            var _query = {};\n            if (query instanceof Query && query._query.query) {\n                _query[\"$nin_query\"] = query._query.query;\n            } else if ((typeof query === 'undefined' ? 'undefined' : _typeof(query)) === \"object\") {\n                _query[\"$nin_query\"] = query;\n            }\n            if (this._query['query'][key]) {\n                this._query['query'][key] = this._query['query'][key].concat(_query);\n            } else {\n                this._query['query'][key] = _query;\n            }\n            return this;\n        }\n\n        /**\n         * @method tags\n         * @memberOf Query\n         * @description Retrieves entries based on the provided tags\n         * @param {Array} values - tags\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.tags(['technology', 'business']).find()\n         *          data.then(function(result) {\n         *        // ‘result’ contains list of entries which have tags \"’technology’\" and ‘\"business’\".\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'tags',\n        value: function tags(values) {\n            if (Array.isArray(values)) {\n                this._query['tags'] = values;\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters\");\n            }\n        }\n\n        /**\n         * @method includeReferenceContentTypeUid\n         * @memberOf Query\n         * @description  This method also includes the content type UIDs of the referenced entries returned in the response.\n         * @example Stack.ContentType(\"contentType_uid\").Query().includeReferenceContentTypeUID().find()\n         * @example \n         * let blogQuery = Stack.ContentType(\"contentType_uid\").Query();\n         *          let data = blogQuery.includeReferenceContentTypeUID().find()\n         *          data.then(function(result) {\n         *         // ‘result’ contains a list of entries in which content type UIDs is present. \n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'includeReferenceContentTypeUID',\n        value: function includeReferenceContentTypeUID() {\n            this._query['include_reference_content_type_uid'] = true;\n            return this;\n        }\n\n        /**\n         * @method includeCount\n         * @memberOf Query\n         * @description Includes the total number of entries returned in the response.\n         * @example blogQuery.includeCount()\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.includeCount().find()\n         *          data.then(function(result) {\n         *         // ‘result’ contains a list of entries in which count of object is present at array[1] position. \n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'includeCount',\n        value: function includeCount() {\n            this._query['include_count'] = true;\n            return this;\n        }\n\n        /**\n         * @method addParam\n         * @description Includes query parameters in your queries.\n         * @memberOf Query\n         * @example var data = blogQuery.addParam('include_count', 'true').fetch()\n         *      data.then(function (result) {\n         *          // 'result' is an object which content the data including count in json object form\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'addParam',\n        value: function addParam(key, value) {\n            if (key && value && typeof key === 'string' && typeof value === 'string') {\n                this._query[key] = value;\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        }\n\n        /**\n         * @method getQuery\n         * @memberOf Query\n         * @description Returns the raw (JSON) query based on the filters applied on Query object.\n         * @example Stack.ContentType('contentType_uid').Query().where('title','Demo').getQuery().find()\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'getQuery',\n        value: function getQuery() {\n            return this._query.query || {};\n        }\n\n        /**\n         * @method regex\n         * @memberOf Query\n         * @description Retrieve entries that match the provided regular expressions\n         * @param {String} key - uid of the field\n         * @param {*} value - value used to match or compare\n         * @param {String} [options] - match or compare value in entry\n         * @example\n         * <caption> .regex without options</caption>\n         * blogQuery.regex('title','^Demo')\n         * @example\n         * <caption> .regex with options</caption>\n         * blogQuery.regex('title','^Demo', 'i')\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'regex',\n        value: function regex(key, value, options) {\n            if (key && value && typeof key === 'string' && typeof value === 'string') {\n                this._query['query'][key] = {\n                    $regex: value\n                };\n                if (options) this._query['query'][key]['$options'] = options;\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        }\n\n        /**\n         * @method search\n         * @memberOf Query\n         * @description Retrieve entries that have fields which match the provided search value.\n         * @param {string} value - value to search in entries\n         * @example blogQuery.search('Welcome to demo')\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.search('welcome to demo').find()\n         *          data.then(function(result) {\n         *         // ‘result’ contains the object that possess the text \"’welcome to demo’\".\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n\n    }, {\n        key: 'search',\n        value: function search(value) {\n            if (value && typeof value === 'string') {\n                this._query['typeahead'] = value;\n                return this;\n            } else {\n                console.error(\"Kindly provide valid parameters.\");\n            }\n        }\n\n        /**\n         * @method find\n         * @memberOf Query\n         * @description Retrieves entries that satisfied the specified query\n         * @example let blogQuery = Stack().ContentType('example').Query().find();\n         *          blogQuery.then(function(result) {\n         *          // result contains the list of object. \n         *       },function (error) {\n         *          // error function\n         *      })\n         * blogQuery.find()\n         * @example\n         * let blogQuery = Stack.ContentType(contentTypeUid).Query().find({\n         *        \n         *      });\n         * blogQuery.then(function(result) {\n         *          // result contains the list of object. \n         *       },function (error) {\n         *          // error function\n         *      })\n         * blogQuery.find()\n         * @returns {promise}\n         * @instance\n         */\n\n    }, {\n        key: 'find',\n        value: function find(fetchOptions) {\n            var host = this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version,\n                url = this.type && this.type === 'asset' ? host + this.config.urls.assets : host + this.config.urls.content_types + this.content_type_uid + this.config.urls.entries;\n            this.requestParams = {\n                method: 'POST',\n                headers: this.headers,\n                url: url,\n                body: {\n                    _method: 'GET',\n                    query: this._query\n                }\n            };\n            var options = Object.assign({}, this.fetchOptions, fetchOptions);\n            return Utils.sendRequest(this, options);\n        }\n\n        /**\n        * @method findOne\n        * @memberOf Query\n        * @deprecated since verion 3.3.0\n        * @description Retrieve a single entry from the result\n        * @example let blogQuery = Stack().ContentType('example').Query().findOne();\n        *          blogQuery.then(function(result) {\n        *          // result contains the single item object. \n        *       },function (error) {\n        *          // error function\n        *      })\n        * blogQuery.findOne()\n        * @returns {promise}\n        * @instance\n        */\n\n    }, {\n        key: 'findOne',\n        value: function findOne() {\n            var host = this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version,\n                url = this.type && this.type === 'asset' ? host + this.config.urls.assets : host + this.config.urls.content_types + this.content_type_uid + this.config.urls.entries;\n            this.singleEntry = true;\n            this._query.limit = 1;\n            this.requestParams = {\n                method: 'POST',\n                headers: this.headers,\n                url: url,\n                body: {\n                    _method: 'GET',\n                    query: this._query\n                }\n            };\n            var options = Object.assign({}, this.fetchOptions);\n            return Utils.sendRequest(this, options);\n        }\n    }]);\n\n    return Query;\n}(_entry2.default);\n\nexports.default = Query;\n\n//# sourceURL=webpack://Contentstack/./src/core/modules/query.js?");

/***/ }),

/***/ "./src/core/modules/result.js":
/*!************************************!*\
  !*** ./src/core/modules/result.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _utils = __webpack_require__(/*! ../lib/utils */ \"./src/core/lib/utils.js\");\n\nvar Utils = _interopRequireWildcard(_utils);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * @class Result\n * @summary Creates an instance of `Result`.\n * @description An initializer is responsible for creating Result object.\n * @param {Object} object - API result object\n * @example\n * blogEntry.then(function (result) {\n *      // sucess function\n * },function (error) {\n *      // error function\n * })\n * @example\n * assetQuery.then(function (result) {\n *      // sucess function\n * },function (error) {\n *      // error function\n * })\n * @returns {Result}\n * @instance \n */\nvar Result = function () {\n    function Result(object) {\n        _classCallCheck(this, Result);\n\n        if (object) {\n            this.object = function () {\n                return object;\n            };\n        }\n        return this;\n    }\n\n    /**\n     * @method toJSON\n     * @memberOf Result\n     * @description Converts `Result` to plain javascript object.\n     * @example\n     * blogEntry.then(function (result) {\n     *      result = result[0][0].toJSON()\n     * },function (error) {\n     *      // error function\n     * })\n     * @example\n     * assetQuery.then(function (result) {\n     *      result = result[0][0].toJSON()\n     * },function (error) {\n     *      // error function\n     * })\n     * @returns {object}\n     * @instance \n     */\n\n\n    _createClass(Result, [{\n        key: 'toJSON',\n        value: function toJSON() {\n            return this.object() ? Utils.mergeDeep(JSON.parse(JSON.stringify({})), this.object()) : null;\n        }\n\n        /**\n          * @method get\n          * @memberOf Result\n          * @description Retrieve details of a field based on the UID provided\n          * @param field_uid uid of the field\n          * @example\n          * blogEntry.then(function (result) {\n          *      let value = result[0][0].get(field_uid)\n          * },function (error) {\n          *      // error function\n          * })\n          * @example\n          * assetQuery.then(function (result) {\n          *      let value = result[0][0].get(field_uid)\n          * },function (error) {\n          *      // error function\n          * })\n          * @returns {promise}\n          * @instance  \n          */\n\n    }, {\n        key: 'get',\n        value: function get(key) {\n            if (this.object() && key) {\n                var fields = key.split('.');\n                var value = fields.reduce(function (prev, field) {\n                    return prev[field];\n                }, this.object());\n                return value;\n            }\n            return;\n        }\n\n        /**\n        * @method getDownloadUrl\n        * @memberOf Result\n        * @description Retrieves the download URL based on the disposition value.\n        * @param {String} string - disposition value\n        * @example\n        * assetQuery.then(function (result) {\n        *      let value = result[0][0].getDownloadUrl(disposition_value)\n        * },function (error) {\n        *      // error function\n        * })\n        * @returns {Object}\n        * @instance    \n        */\n\n    }, {\n        key: 'getDownloadUrl',\n        value: function getDownloadUrl(disposition) {\n            if (this.object()) {\n                var url = this.object().url ? this.object().url : null,\n                    _disposition = disposition && typeof disposition === 'string' ? disposition : 'attachment';\n                return url ? url + '?disposition=' + _disposition : null;\n            }\n        }\n    }]);\n\n    return Result;\n}();\n\nmodule.exports = function (object) {\n    return new Result(object);\n};\n\n//# sourceURL=webpack://Contentstack/./src/core/modules/result.js?");

/***/ }),

/***/ "./src/core/stack.js":
/*!***************************!*\
  !*** ./src/core/stack.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _config = __webpack_require__(/*! ../../config */ \"./config.js\");\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _utils = __webpack_require__(/*! ./lib/utils */ \"./src/core/lib/utils.js\");\n\nvar Utils = _interopRequireWildcard(_utils);\n\nvar _entry = __webpack_require__(/*! ./modules/entry */ \"./src/core/modules/entry.js\");\n\nvar _entry2 = _interopRequireDefault(_entry);\n\nvar _assets = __webpack_require__(/*! ./modules/assets */ \"./src/core/modules/assets.js\");\n\nvar _assets2 = _interopRequireDefault(_assets);\n\nvar _query = __webpack_require__(/*! ./modules/query */ \"./src/core/modules/query.js\");\n\nvar _query2 = _interopRequireDefault(_query);\n\nvar _request = __webpack_require__(/*! ./lib/request */ \"./src/core/lib/request.js\");\n\nvar _request2 = _interopRequireDefault(_request);\n\nvar _cache = __webpack_require__(/*! ./cache */ \"./src/core/cache.js\");\n\nvar cache = _interopRequireWildcard(_cache);\n\nvar _index = __webpack_require__(/*! ./cache-provider/index */ \"./src/core/cache-provider/index.js\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar errorRetry = [408, 429];\n\n/**\n     * @class \n        Stack \n     * @description Initialize an instance of ‘Stack’\n     * @param api_key - Stack API Key.\n     * @param delivery_token - Stack Delivery token.\n     * @param environment - Stack Environment name.\n     * @param region - DB region for Stack.\n     * @param fetchOptions - Custom setting for the request.\n     * @param fetchOptions.timeout - Set timeout for the request.\n     * @param fetchOptions.retryLimit - The number of retries before failure. Default is 5\n     * @param fetchOptions.retryDelay - The number of ms to use for operation retries. Default is 300ms\n     * @param fetchOptions.retryCondition - A function to determine if the error can be retried. Default retry is on status codes 408, 429, and greter than equal to 500.\n     * @param fetchOptions.retryDelayOptions.base - The base number of milliseconds to use in the exponential backoff for operation retries.\n     * @param fetchOptions.retryDelayOptions.customBackoff - A custom function that accepts a retry count and error and returns the amount of time to delay in milliseconds.\n     * @example\n     * var Stack = Contentstack.Stack({\n     *      'api_key':'api_key',\n     *      'delivery_token':'delivery_token',\n     *      'environment':'environment_name',\n     *      'region': 'us',\n     *      'fetchOptions': {\n     *       \n     *      }\n     * });\n     * \n     * @example\n     * var Stack = Contentstack.Stack('api_key', 'access_token', 'environment', {\n     * \n     * });\n     * \n     * @example\n     * // For Setting the European Region:\n     * // If you want to set and use European region, refer to the code below:\n     * const Stack = Contentstack.Stack(\"api_key\", \"delivery_token\", \"environment_name\", Contentstack.Region.EU);\n     * \n     * @returns {Stack}\n     * @instance\n     */\n\nvar Stack = function () {\n    function Stack() {\n        _classCallCheck(this, Stack);\n\n        this.fetchOptions = {\n            retryLimit: 5,\n            retryCondition: function retryCondition(error) {\n                if (errorRetry.includes(error.status)) {\n                    return true;\n                }\n                return false;\n            }\n        };\n        this.config = Object.assign({}, _config2.default);\n\n        for (var _len = arguments.length, stack_arguments = Array(_len), _key = 0; _key < _len; _key++) {\n            stack_arguments[_key] = arguments[_key];\n        }\n\n        if (stack_arguments[0].region && stack_arguments[0].region !== undefined && stack_arguments[0].region !== \"us\") {\n            this.config['host'] = stack_arguments[0].region + \"-\" + \"cdn.contentstack.com\";\n        }\n\n        if (stack_arguments[0].fetchOptions && stack_arguments[0].fetchOptions !== undefined) {\n            this.fetchOptions = Object.assign(this.fetchOptions, stack_arguments[0].fetchOptions);\n        }\n\n        this.cachePolicy = _index2.default.policies.IGNORE_CACHE;\n        this.provider = _index2.default.providers('localstorage');\n\n        switch (stack_arguments.length) {\n            case 1:\n                if (_typeof(stack_arguments[0]) === \"object\" && typeof stack_arguments[0].api_key === \"string\" && typeof stack_arguments[0].delivery_token === \"string\" && typeof stack_arguments[0].environment === \"string\") {\n                    this.headers = {\n                        api_key: stack_arguments[0].api_key,\n                        access_token: stack_arguments[0].delivery_token\n                    };\n                    this.environment = stack_arguments[0].environment;\n                    return this;\n                } else {\n                    console.error(\"Kindly provide valid object parameters. The specified API Key, Delivery Token, or Environment Name is invalid.\");\n                }\n            case 3:\n                if (typeof stack_arguments[0] === \"string\" && typeof stack_arguments[1] === \"string\" && typeof stack_arguments[2] === \"string\") {\n                    this.headers = {\n                        api_key: stack_arguments[0],\n                        access_token: stack_arguments[1]\n                    };\n                    this.environment = stack_arguments[2];\n                    return this;\n                } else {\n                    console.error(\"Kindly provide valid string parameters.\");\n                }\n            case 4:\n                if (typeof stack_arguments[0] === \"string\" && typeof stack_arguments[1] === \"string\" && typeof stack_arguments[2] === \"string\") {\n                    this.headers = {\n                        api_key: stack_arguments[0],\n                        access_token: stack_arguments[1]\n                    };\n                    this.environment = stack_arguments[2];\n                } else {\n                    console.error(\"Kindly provide valid string parameters.\");\n                }\n                if (stack_arguments[3]) {\n                    if (typeof stack_arguments[3] === \"string\" && stack_arguments[3] !== undefined && stack_arguments[3] !== \"us\") {\n                        this.config['host'] = stack_arguments[3] + \"-\" + \"cdn.contentstack.com\";\n                    } else if (_typeof(stack_arguments[3]) === 'object') {\n                        this.fetchOptions = Object.assign(this.fetchOptions, stack_arguments[3]);\n                    }\n                }\n                return this;\n            case 5:\n                if (typeof stack_arguments[0] === \"string\" && typeof stack_arguments[1] === \"string\" && typeof stack_arguments[2] === \"string\") {\n                    this.headers = {\n                        api_key: stack_arguments[0],\n                        access_token: stack_arguments[1]\n                    };\n                    this.environment = stack_arguments[2];\n                } else {\n                    console.error(\"Kindly provide valid string parameters.\");\n                }\n\n                if (stack_arguments[3]) {\n                    if (typeof stack_arguments[3] === \"string\" && stack_arguments[3] !== undefined && stack_arguments[3] !== \"us\") {\n                        this.config['host'] = stack_arguments[3] + \"-\" + \"cdn.contentstack.com\";\n                    } else if (_typeof(stack_arguments[3]) === 'object') {\n                        this.fetchOptions = Object.assign(this.fetchOptions, stack_arguments[3]);\n                    }\n                }\n                if (stack_arguments[4] && _typeof(stack_arguments[4]) === 'object') {\n                    this.fetchOptions = Object.assign(this.fetchOptions, stack_arguments[4]);\n                }\n                return this;\n            default:\n                console.error(\"Kindly provide valid parameters to initialize the Contentstack javascript-SDK Stack.\");\n        }\n    }\n\n    /**\n     * @method setPort\n     * @memberOf Stack\n     * @description Sets the port of the host\n     * @param {Number} port - Port Number\n     * @return {Stack}\n     * @instance\n     * */\n\n\n    _createClass(Stack, [{\n        key: 'setPort',\n        value: function setPort(port) {\n            if (typeof port === \"number\") this.config.port = port;\n            return this;\n        }\n\n        /**\n         * @method setProtocol\n         * @memberOf Stack\n         * @description Sets the protocol for the host\n         * @param {String} protocol - http/https protocol\n         * @return {Stack}\n         * @instance\n         * */\n\n    }, {\n        key: 'setProtocol',\n        value: function setProtocol(protocol) {\n            if (typeof protocol === \"string\" && ~[\"https\", \"http\"].indexOf(protocol)) this.config.protocol = protocol;\n            return this;\n        }\n\n        /**\n         * @method setHost\n         * @memberOf Stack\n         * @description Sets the host of the API server\n         * @param {String} host - valid ip or host\n         * @return {Stack}\n         * @instance\n         * */\n\n    }, {\n        key: 'setHost',\n        value: function setHost(host) {\n            if (typeof host === \"string\" && host) this.config.host = host;\n            return this;\n        }\n\n        /**\n         * @method setCachePolicy\n         * @memberOf Stack\n         * @description Allows you to set cache policies\n         * @param {Constant} [key=ONLY_NETWORK] - Cache policy to be applied on Stack or Query.\n         * @example\n         * Stack.setCachePolicy(Contentstack.CachePolicy.IGNORE_CACHE)\n         * Stack.setCachePolicy(Contentstack.CachePolicy.ONLY_NETWORK)\n         * Stack.setCachePolicy(Contentstack.CachePolicy.CACHE_ELSE_NETWORK)\n         * Stack.setCachePolicy(Contentstack.CachePolicy.NETWORK_ELSE_CACHE)\n         * Stack.setCachePolicy(Contentstack.CachePolicy.CACHE_THEN_NETWORK)\n         * @returns {Stack}\n         * @instance\n         */\n\n    }, {\n        key: 'setCachePolicy',\n        value: function setCachePolicy(policy) {\n            if (typeof policy === 'number' && policy >= -1 && policy < 4) {\n                if (!this._query) {\n                    this.cachePolicy = policy;\n                } else {\n                    this.queryCachePolicy = policy;\n                }\n            } else {\n                console.error(\"Kindly provide the valid policy\");\n            }\n            return this;\n        }\n\n        /**\n        * @method setCacheProvider\n        * @memberOf Stack\n        * @description Allows you to set an object of the cache provider\n        * @example\n        * Stack\n        *      .setCacheProvider({\n        *          get: function (key, callback) {\n        *              // custom logic\n        *          },\n        *          set: function (key, value, callback) {\n        *              // custom logic\n        *          }\n        *      });\n        * @returns {Stack}\n        * @instance\n        */\n\n    }, {\n        key: 'setCacheProvider',\n        value: function setCacheProvider(provider) {\n            if (provider && (typeof provider === 'undefined' ? 'undefined' : _typeof(provider)) === 'object') {\n                this.provider = provider;\n            }\n            return this;\n        }\n\n        /**\n         * @method clearByQuery\n         * @memberOf Stack\n         * @description 'clearByQuery' function to clear the query from the cache.\n         * @example\n         * Stack.clearQuery(query, callback);\n         * @returns {Stack}\n         * @instance\n         */\n\n    }, {\n        key: 'clearByQuery',\n        value: function clearByQuery() {\n            if (this.provider && typeof this.provider.clearByQuery === 'function') {\n                return this.provider.clearByQuery.apply(this.provider, arguments);\n            }\n        }\n\n        /**\n         * @method clearByContentType\n         * @memberOf Stack\n         * @description 'clearByContentType' function to clear the query from the cache by specified content type.\n         * @example\n         * Stack.clearByContentType(content_type_uid, callback);\n         * Stack.clearByContentType(content_type_uid, language_uid, callback);\n         * @returns {Stack}\n         * @instance\n         */\n\n    }, {\n        key: 'clearByContentType',\n        value: function clearByContentType() {\n            if (this.provider && typeof this.provider.clearByContentType === 'function') {\n                return this.provider.clearByContentType.apply(this.provider, arguments);\n            }\n        }\n\n        /**\n         * @method clearAll\n         * @memberOf Stack\n         * @description 'clearAll' function to clear all the queries from cache.\n         * @example\n         * Stack.clearAll(callback);\n         * @returns {Stack}\n         * @instance   \n         */\n\n    }, {\n        key: 'clearAll',\n        value: function clearAll() {\n            if (this.provider && typeof this.provider.clearAll === 'function') {\n                return this.provider.clearAll.apply(this.provider, arguments);\n            }\n        }\n\n        /**\n          * @method getCacheProvider\n          * @memberOf Stack\n          * @description Returns the currently set object of 'CacheProvider'\n          * @example Stack.getCacheProvider();\n          * @returns {object}\n          * @instance\n          */\n\n    }, {\n        key: 'getCacheProvider',\n        value: function getCacheProvider() {\n            return this.provider;\n        }\n\n        /**\n          * @method ContentType\n          * @memberOf Stack\n          * @description Set the content type of which you want to retrieve the entries\n          * @param {String} [content_type_uid] - uid of the existing content type\n          * @example \n          * let data = Stack.ContentType('blog').Query().toJSON().find()\n          *      data\n          *      .then(function(result) {\n          *           // 'result' content the list of entries of particular content type blog.       \n          *      }, function(error) {\n          *           // error function\n          *      })\n          * @returns {Stack}\n          * @instance\n          */\n\n    }, {\n        key: 'ContentType',\n        value: function ContentType(uid) {\n            if (uid && typeof uid === 'string') {\n                this.content_type_uid = uid;\n                this.type = \"contentType\";\n            }\n            return this;\n        }\n\n        /**\n            * @method Entry\n            * @memberOf ContentType\n            * @param {String} uid - uid of the entry \n            * @description An initializer is responsible for creating Entry object\n            * @returns {Entry}\n            * @instance \n            */\n\n    }, {\n        key: 'Entry',\n        value: function Entry(uid) {\n            var entry = new _entry2.default();\n            if (uid && typeof uid === \"string\") {\n                entry.entry_uid = uid;\n            }\n            return Utils.merge(entry, this);\n        }\n\n        /**\n        * @method fetch\n        * @memberOf ContentType\n        * @description This method returns the complete information of a specific content type.\n        * @example\n        * let single_contenttype = Stack.ContentType(content_type_uid).fetch()\n        *    single_contenttype\n        *    .then(function(result) {\n        *      // 'result' is a single contentType information.       \n        *     }).catch((error) => {\n        *        console.log(error)\n        *  });\n        * @returns {promise}\n        * @instance \n        */\n\n    }, {\n        key: 'fetch',\n        value: function fetch(fetchOptions) {\n            var result = {\n                method: 'POST',\n                headers: this.headers,\n                url: this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.content_types + this.content_type_uid,\n                body: {\n                    _method: 'GET',\n                    environment: this.environment\n                }\n            };\n            var options = Object.assign({}, this.fetchOptions, fetchOptions);\n            return (0, _request2.default)(result, options);\n        }\n\n        /**\n           * @method Assets\n           * @memberOf Stack\n           * @param {String} uid - uid of the asset \n           * @description Retrieves all assets of a stack by default. To retrieve a single asset, specify its UID.\n           * @example \n           * // Retrieves all assets\n           * let data = Stack.Assets().Query().toJSON().find()\n           *      data\n           *      .then(function(result) {\n           *          // All the asset with limit of 100\n           *          // Use skip and limit functions to paginate\n           *          // ‘result’ will display all assets present in stack       \n           *      }, function(error) {\n           *           // error function\n           *      })\n           * \n           * @example \n           * let data = Stack.Assets('bltsomething123').toJSON().fetch()\n           *      data\n           *        .then(function(result) {\n           *           // ‘result’ is a single asset object of specified uid       \n           *      }, function(error) {\n           *           // error function\n           *      })\n           * \n           * @returns {Assets}\n           * @instance \n           */\n\n    }, {\n        key: 'Assets',\n        value: function Assets(uid) {\n            this.type = 'asset';\n            if (uid && typeof uid === \"string\") {\n                var asset = new _assets2.default();\n                asset.asset_uid = uid;\n                return Utils.merge(asset, this);\n            }\n            return this;\n        }\n\n        /**\n            * @method Query\n            * @memberOf Stack\n            * @description An initializer is responsible for creating Query object.Provides support for all search queries\n            * @returns {Query}\n            * @instance  \n            */\n\n    }, {\n        key: 'Query',\n        value: function Query() {\n            var query = new _query2.default();\n            return Utils.merge(query, this);\n        }\n\n        /**\n          * @method getLastActivites\n          * @memberOf Stack\n          * @description getLastActivites get all the ContentTypes whose last activity updated.\n          * @example Stack.getLastActivites()\n          * @example \n          * let data = Stack.getLastActivites().toJSON().fetch()\n          *      data\n          *      .then(function(result) {\n          *           // 'result' is list of contentTypes whose last activity updated.       \n          *      }, function(error) {\n          *           // error function\n          *      })\n          * @returns {promise}\n          * @instance\n          */\n\n    }, {\n        key: 'getLastActivities',\n        value: function getLastActivities() {\n            var query = {\n                method: 'POST',\n                headers: this.headers,\n                url: this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.content_types,\n                body: {\n                    _method: 'GET',\n                    only_last_activity: true,\n                    environment: this.environment\n                }\n            };\n            return (0, _request2.default)(query, this.fetchOptions);\n        }\n\n        /**\n        * @method getContentTypes\n        * @memberOf Stack\n        * @param {String} param - Query on contentTypes\n        * @description This method returns comprehensive information of all the content types of a particular stack in your account.\n        * @example \n        * let data = Stack.getContentTypes({\"include_global_field_schema\": true})\n        *      data\n        *      .then(function(result) {\n        *           // 'result' is list of contentTypes.       \n        *      }, function(error) {\n        *           // error function\n        *      })\n        * @returns {promise}\n        * @instance\n        */\n\n    }, {\n        key: 'getContentTypes',\n        value: function getContentTypes() {\n            var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            var query = {\n                method: 'POST',\n                headers: this.headers,\n                url: this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.content_types,\n                body: {\n                    _method: 'GET',\n                    environment: this.environment\n                }\n            };\n            if (param && param !== undefined) {\n                for (var key in param) {\n                    query.body[key] = param[key];\n                }\n            }\n            return (0, _request2.default)(query, this.fetchOptions);\n        }\n\n        /**\n         * @method sync\n         * @memberOf Stack\n         * @description Syncs your Contentstack data with your app and ensures that the data is always up-to-date by providing delta updates\n         * @param {object} params - params is an object that supports ‘locale’, ‘start_date’, ‘content_type_uid’, and ‘type’ queries.\n         * @example \n         * Stack.sync({'init': true})        // For initializing sync\n         * @example \n         * Stack.sync({'init': true, 'locale': 'en-us'})     //For initializing sync with entries of a specific locale\n         * @example \n         * Stack.sync({'init': true, 'start_date': '2018-10-22'})    //For initializing sync with entries published after a specific date\n         * @example \n         * Stack.sync({'init': true, 'content_type_uid': 'session'})   //For initializing sync with entries of a specific content type\n         * @example \n         * Stack.sync({'init': true, 'type': 'entry_published'})   //Use the type parameter to get a specific type of content.Supports 'asset_published', 'entry_published', 'asset_unpublished', 'entry_unpublished', 'asset_deleted', 'entry_deleted', 'content_type_deleted'.\n         * @example \n         * Stack.sync({'pagination_token': '<btlsomething>'})    // For fetching the next batch of entries using pagination token\n         * @example \n         * Stack.sync({'sync_token': '<btlsomething>'})    // For performing subsequent sync after initial sync\n         * @returns {promise}\n         * @instance\n         */\n\n    }, {\n        key: 'sync',\n        value: function sync(params, fetchOptions) {\n            this._query = {};\n            this._query = Object.assign(this._query, params);\n            this.requestParams = {\n                method: 'POST',\n                headers: this.headers,\n                url: this.config.protocol + \"://\" + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.sync,\n                body: {\n                    _method: 'GET',\n                    query: this._query\n                }\n            };\n            var options = Object.assign({}, this.fetchOptions, fetchOptions);\n            return Utils.sendRequest(this, options);\n        }\n\n        /**\n         * @method imageTransform\n         * @memberOf Stack\n         * @description Performs transformations on images of mentioned url based on transformation parameters \n         * @param {String} url - Image url on which transformations need to be applied.\n         * @param {String} params - Object with transformation parameters\n         * @example\n         * Stack.imageTransform(imageURL, {height: 100, width: 200, disable: \"upscale\"});\n         * @example\n         * Stack.imageTransform(imageURL, {crop: \"150,100\"});\n         * @example\n         * Stack.imageTransform(imageURL, {format: \"png\", crop: \"150,100\"});\n         * @returns {string} [Image url with transformation parameters.]\n         * @instance\n         */\n\n    }, {\n        key: 'imageTransform',\n        value: function imageTransform(url, params) {\n            if (url && typeof url === \"string\" && (typeof params === 'undefined' ? 'undefined' : _typeof(params)) === \"object\" && params.length === undefined) {\n                var queryParams = [];\n                for (var operation in params) {\n                    queryParams.push(operation + '=' + params[operation]);\n                }\n                url += url.indexOf(\"?\") <= -1 ? \"?\" + queryParams.join('&') : \"&\" + queryParams.join('&');\n            }\n\n            return url;\n        }\n    }]);\n\n    return Stack;\n}();\n\nexports.default = Stack;\n\n//# sourceURL=webpack://Contentstack/./src/core/stack.js?");

/***/ }),

/***/ "./src/runtime/node/http.js":
/*!**********************************!*\
  !*** ./src/runtime/node/http.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _es6Promise = __webpack_require__(/*! es6-promise */ \"./node_modules/es6-promise/dist/es6-promise.js\");\n\nvar _es6Promise2 = _interopRequireDefault(_es6Promise);\n\nvar _nodeFetch = __webpack_require__(/*! node-fetch */ \"./node_modules/node-fetch/lib/index.mjs\");\n\nvar _nodeFetch2 = _interopRequireDefault(_nodeFetch);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_es6Promise2.default.polyfill();\n\nexports.default = _nodeFetch2.default;\n\n//# sourceURL=webpack://Contentstack/./src/runtime/node/http.js?");

/***/ }),

/***/ "./src/runtime/node/localstorage.js":
/*!******************************************!*\
  !*** ./src/runtime/node/localstorage.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _localStorage = __webpack_require__(/*! localStorage */ \"./node_modules/localStorage/lib/localStorage.js\");\n\nvar _localStorage2 = _interopRequireDefault(_localStorage);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = _localStorage2.default;\n\n//# sourceURL=webpack://Contentstack/./src/runtime/node/localstorage.js?");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"http\");\n\n//# sourceURL=webpack://Contentstack/external_%22http%22?");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"https\");\n\n//# sourceURL=webpack://Contentstack/external_%22https%22?");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"stream\");\n\n//# sourceURL=webpack://Contentstack/external_%22stream%22?");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"url\");\n\n//# sourceURL=webpack://Contentstack/external_%22url%22?");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"zlib\");\n\n//# sourceURL=webpack://Contentstack/external_%22zlib%22?");

/***/ })

/******/ });
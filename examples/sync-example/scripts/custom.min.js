(function() {
    if (!Contentstack) {
        alert('Please add Contentstack Library');
    } else {
        var clearAll = document.getElementById('all');
        var clearByContentType = document.getElementById('content_type');
        var clearByQuery = document.getElementById('query');
        var wrapper, Stack;

        function DOMCreation(entry, html) {
            if (entry) {
                html += '<div class="panel panel-default"><div class="panel-heading" role="tab"><h4 class="panel-title"><a role="button" data-toggle="collapse" data-parent="#accordion" href="#' + entry.uid + '" aria-expanded="true" aria-controls="' + entry.uid + '">';
                html += entry.title + '</a></h4></div><div id="' + entry.uid + '" class="panel-collapse collapse" role="tabpanel"><div class="panel-body">';
                html += entry.url + ' </div></div></div>';
            }
            return html;
        }


        // This function check LocalStorage for existing data 
        function checkLocalStorage() {
            if (localStorage.getItem("sync_token")) {
                getSyncData();
            } else {
                getData();
            }
        }


        // This function will call init method of Sync        
        function getData() {
            let toBeStoredAssets = {};
            let toBeStoredEntries = {};
            let api_key,
                _env;
            Stack
                .sync({
                    "init": "true"
                })
                .toJSON()
                .fetch()
                .then(function(data) {
                    let result = data[0].items;
                    api_key = Stack.headers.api_key;
                    _env = Stack.environment;


                    if (result.length > 0) {
                        for (i = 0; i < result.length; i++) {
                            if (result[i].type === "asset_published") {
                                toBeStoredAssets["Assets"] = toBeStoredAssets["Assets"] || []
                                toBeStoredAssets["Assets"].push(result[i].data);

                            } else {
                                toBeStoredEntries[result[i].content_type_uid] = toBeStoredEntries[result[i].content_type_uid] || []
                                toBeStoredEntries[result[i].content_type_uid].push(result[i].data);
                            }
                        }
                    }

                    for (let contentType in toBeStoredEntries) {
                        localStorage.setItem(api_key + "." + _env + "." + contentType, JSON.stringify(toBeStoredEntries[contentType]))
                    }
                    for (let assets in toBeStoredAssets) {

                        localStorage.setItem(api_key + "." + _env + "." + assets, JSON.stringify(toBeStoredAssets[assets]))
                    }
                    if (data[0].sync_token) {
                        localStorage.setItem("sync_token", data[0].sync_token)
                    }
                });
        }




        //This Function will fetch the new data using sync_token
        function getSyncData() {
            let toBeStoredAssets = {},
                toBeStoredEntries = {},
                toBeDeleteddata = {}
            let api_key,
                _env;
            let sync_token = localStorage.getItem("sync_token");
            Stack
                .sync({
                    "sync_token": sync_token
                })
                .toJSON()
                .fetch()
                .then(function(data) {
                    api_key = Stack.headers.api_key;
                    _env = Stack.environment
                    let result = data[0].items;
                    if (result && result.length) {
                        for (i = 0; i < result.length; i++) {
                            if (result[i].type === "asset_published") {
                                toBeStoredAssets[api_key + "." + _env + "." + "Assets"] = toBeStoredAssets[api_key + "." + _env + "." + "Assets"] || []
                                toBeStoredAssets[api_key + "." + _env + "." + "Assets"].push(result[i].data);
                            } else if (result[i].type === "entry_published") {
                                toBeStoredEntries[api_key + "." + _env + "." + result[i].content_type_uid] = toBeStoredEntries[api_key + "." + _env + "." + result[i].content_type_uid] || []
                                toBeStoredEntries[api_key + "." + _env + "." + result[i].content_type_uid].push(result[i].data);
                            } else {
                                toBeDeleteddata[api_key + "." + _env + "." + result[i].content_type_uid] = toBeDeleteddata[api_key + "." + _env + "." + result[i].content_type_uid] || []
                                toBeDeleteddata[api_key + "." + _env + "." + result[i].content_type_uid].push(result[i].data);
                            }
                        }
                    }


                    if (Object.keys(toBeStoredEntries).length) {
                        for (let contentType in toBeStoredEntries) {
                            if (localStorage.getItem(contentType)) {
                                let existing_data = JSON.parse(localStorage.getItem(contentType))
                                for (i = 0; i < toBeStoredEntries[contentType].length; i++) {
                                    for (j = 0; j < existing_data.length; j++) {
                                        if (toBeStoredEntries[contentType][i].uid === existing_data[j].uid && existing_data[j]._version < toBeStoredEntries[contentType][i]._version) {
                                            const index = j;
                                            existing_data.splice(index, 1);
                                        }
                                    }
                                }
                                let final_data = existing_data.concat(toBeStoredEntries[contentType])
                                localStorage.setItem(contentType, JSON.stringify(final_data));
                            }
                        }
                    }


                    if (Object.keys(toBeStoredAssets).length) {
                        for (let assets in toBeStoredAssets) {
                            if (localStorage.getItem(assets)) {
                                let existing_data = JSON.parse(localStorage.getItem(assets))
                                for (i = 0; i < toBeStoredAssets[assets].length; i++) {
                                    for (j = 0; j < existing_data.length; j++) {
                                        if (toBeStoredAssets[assets][i].uid === existing_data[j].uid && existing_data[j]._version < toBeStoredAssets[assets][i]._version) {
                                            const index = j;
                                            existing_data.splice(index, 1);
                                        }
                                    }
                                }
                                let final_data = existing_data.concat(toBeStoredAssets[assets])
                                localStorage.setItem(assets, JSON.stringify(final_data));
                            }
                        }
                    }


                    if (Object.keys(toBeDeleteddata).length) {
                        for (let deleted_item in toBeDeleteddata) {
                            let existing_data;
                            let _deleted_item;
                            if (deleted_item === api_key + "." + _env + "." + "sys_assets") {

                                _deleted_item = api_key + "." + _env + "." + "Assets";
                                existing_data = JSON.parse(localStorage.getItem(_deleted_item))
                            } else {
                                _deleted_item = deleted_item
                                existing_data = JSON.parse(localStorage.getItem(_deleted_item))
                            }

                            if (localStorage.getItem(_deleted_item)) {
                                for (i = 0; i < toBeDeleteddata[deleted_item].length; i++) {
                                    for (j = 0; j < existing_data.length; j++) {
                                        if (toBeDeleteddata[deleted_item][i].uid === existing_data[j].uid) {
                                            const index = j;
                                            existing_data.splice(index, 1);
                                        }
                                    }
                                }
                                let final_data = existing_data
                                console.log("data", final_data)
                                localStorage.setItem(_deleted_item, JSON.stringify(final_data));
                            }
                        }
                    }
                    localStorage.setItem("sync_token", data[0].sync_token);

                }, function(err) {
                    console.info('Error : ' + err);
                });
        }


        window.onload = function() {
            wrapper = document.getElementById('wrapper')
            Stack = Contentstack.Stack({
                'api_key': 'blt123something',
                'access_token': 'blt123something',
                'environment': 'mobile'
            })
            checkLocalStorage()
        }
    }
}());